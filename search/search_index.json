{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Jakarta EE 11","text":"<p>Followed the releases of the Jakarta EE 11 Core Profile and Web Profile in the past months, the Eclipse Foundation has now officially launched the final version of the Jakarta EE 11 platform.</p>"},{"location":"#history","title":"History","text":"<p>Since the Eclipse Foundation took over Java EE, Jakarta EE has continued to evolve at a steady pace.</p> <ul> <li>Jakarta EE 8/9: These versions focused on foundational changes, with Jakarta EE 8 primarily renaming Maven coordinates from <code>javax</code> to <code>jakarta</code>, and Jakarta EE 9/9.1 cleaning up the new <code>jakarta</code> namespace at the API source code level.</li> <li>Jakarta EE 10: This release introduced significant new features, including the Core Profile, the Jakarta Contexts and Dependency Injection Lite specification, and enhancements to existing specifications. Jakarta EE 10 set Java 11 as the minimum requirement and added support for Java 17 at runtime.</li> <li>Jakarta EE 11: The latest release continues to improve the developer experience and further deprecates outdated APIs. Jakarta EE 11 now uses Java 17 as its baseline and supports Java 21 at runtime. For specification implementors, this release modernizes the Jakarta EE TCK by updating it to the latest Arquillian and JUnit 5, making it easier for more implementors to align with the new specifications.</li> </ul> <p>Let\u2019s take a closer look at what\u2019s new in Jakarta EE 11.</p>"},{"location":"#whats-new-in-jakarta-ee-11","title":"What's New In Jakarta EE 11","text":""},{"location":"#new-specifications","title":"New Specifications","text":"<p>Jakarta EE 11 introduces a major new specification: Jakarta Data.</p> <p>Jakarta Data has been in incubation for two years and has seen active development throughout. Now, it officially joins the Jakarta EE 11 release train. To get started, check out the Jakarta Data specification. The Hibernate documentation also features a dedicated chapter, Hibernate Data Repositories, with practical examples of Jakarta Data in action.</p>"},{"location":"#updates","title":"Updates","text":"<p>The Java <code>record</code> type is now a first-class citizen in Jakarta EE. Specifications such as Persistence, Faces, Expression Language, and Validation have all embraced <code>record</code> types. However, JSON-B has not yet been updated to support records (though GlassFish\u2019s implementation does), and using records as Messaging payloads can be problematic if they do not implement <code>Serialization</code>\u2014see jakartaee/messaging#343 for details.</p> <p>Several specifications have received notable updates in Jakarta EE 11:</p> <ul> <li>CDI 4.1: The core of the Jakarta EE ecosystem now includes several enhancements. For developers, the ability to use <code>@Priority</code> on producers is a key highlight. For implementers, the CDI EE integration has been moved to the Jakarta platform specification. See What's new in CDI 4.1 for more information.</li> <li>Persistence 3.2: This release brings many small improvements, such as supporting <code>record</code> types as embeddable classes, adding more SQL-specific functions to JPQL, and enabling programmatic configuration as an alternative to <code>persistence.xml</code>.</li> <li>Concurrency 3.1: Now supports Java 21 virtual threads in managed execution services and Java 9 <code>Flow</code> (ReactiveStreams) in context propagation. It also introduces a new <code>@Schedule</code> annotation (nested in <code>@Asynchronous</code>) to replace the legacy EJB version.</li> <li>REST 4.0: Adds support for JSON Merge Patch, enhancing RESTful API capabilities.</li> <li>Security 4.0: Introduces a new in-memory <code>IdentityStore</code>\u2014very useful for development\u2014and adds support for multiple authentication mechanisms.</li> </ul> <p>The <code>ManagedBean</code> specification has been removed from Jakarta EE 11. Additionally, starting with this release, the SOAP-based Web Service specification is marked as deprecated and is not recommended for new projects. References to <code>SecurityManager</code> are being phased out due to its deprecation in future Java SE runtimes. While some specifications have already removed <code>SecurityManager</code> APIs, the remainder will be addressed in Jakarta EE 12.</p> <p>We will explore these new features with example code in future posts.</p>"},{"location":"#under-maintenance","title":"Under Maintenance","text":"<p>The following specifications remain unchanged in Jakarta EE 11:</p> <ul> <li>Jakarta JSON-B</li> <li>Jakarta JSON-P</li> <li>Jakarta Messaging</li> <li>Jakarta Batch</li> <li>Jakarta Activation</li> <li>Jakarta Mail</li> </ul>"},{"location":"#the-future-of-jakarta-ee","title":"The Future of Jakarta EE","text":"<p>With Jakarta EE now fully community-driven, everyone can participate in shaping the future of the platform.</p> <p>Several new features are under discussion and may become specifications in the future, including:</p> <ul> <li>Jakarta RPC \u2013 Standardizing gRPC support in the Jakarta EE ecosystem.</li> <li>Jakarta NoSQL \u2013 Introducing a general-purpose <code>Repository</code> pattern and <code>Template</code> APIs for NoSQL databases.</li> <li>Jakarta MVC \u2013 Providing an action-based web framework, similar to Apache Struts or Spring MVC, based on the existing Jakarta REST specification. (Note: This is not a replacement for Jakarta Faces.)</li> <li>Common HTTP APIs \u2013 Discussions are ongoing about introducing a unified set of HTTP APIs to streamline HTTP handling across specifications. Currently, Faces reuses the Servlet API, and MVC reuses the REST API.</li> </ul> <p>For more information about Jakarta EE, please visit the official Jakarta EE homepage.</p>"},{"location":"concurrency/","title":"What's New in Jakarta Concurrency 3.1?","text":"<p>Jakarta Concurrency provides a standard API for managing concurrent tasks in Jakarta EE applications. It exposes managed executor services, thread factories, and context propagation helpers so that concurrent work runs with container-managed concurrency resources.</p> <p>Jakarta Concurrency 3.1 introduces several notable improvements:</p> <ul> <li>Integration with Java 21 virtual threads</li> <li>Improved CDI support for injecting concurrency resources</li> <li>A new <code>@Schedule</code> annotation for task scheduling</li> <li>Java 9 Flow / Reactive Streams support</li> </ul> <p>We covered virtual threads in an earlier post \u2014 Virtual Thread Support in Jakarta EE 11 \u2014 and showed how to define concurrency resources with CDI <code>@Qualifier</code>s so they can be injected like regular CDI beans.</p> <p>In this post, we'll skip those topics and focus on the new <code>@Schedule</code> annotation and the Reactive Streams support.</p>"},{"location":"concurrency/#new-schedule-annotation","title":"New <code>@Schedule</code> Annotation","text":"<p>Legacy task scheduling has long been tied to the EJB container. Porting EJB functionalities to CDI-compatible APIs has been a long-standing effort (see discussion). The new <code>@Schedule</code> annotation aims to replace the EJB scheduling annotation and provide a more portable, CDI-friendly mechanism.</p> <p>The example below demonstrates a simple usage of <code>@Schedule</code>.</p> <p>Suppose we need to notify team members about a recurring project meeting. The bean below uses <code>@Schedule</code> to trigger those notifications.</p> <pre><code>@ApplicationScoped\npublic class StandUpMeeting {\n    private static final Logger LOGGER = Logger.getLogger(StandUpMeeting.class.getName());\n\n    private static final Map&lt;String, String&gt; members = Map.of(\n            \"jack\", \"jack@example.com\",\n            \"ross\", \"ross@example.com\"\n    );\n\n    @Inject\n    ManagedThreadFactory threadFactory;\n\n    @Inject\n    NotificationService notificationService;\n\n    @PostConstruct\n    public void init() {\n        LOGGER.log(Level.ALL, \"init from scheduled tasks...\");\n    }\n\n    @Asynchronous(\n            runAt = {\n                    @Schedule(\n                            daysOfWeek = {\n                                    DayOfWeek.MONDAY,\n                                    DayOfWeek.TUESDAY,\n                                    DayOfWeek.WEDNESDAY,\n                                    DayOfWeek.THURSDAY,\n                                    DayOfWeek.FRIDAY\n                            },\n                            hours = 8\n                    ), // daily standup\n                    @Schedule(daysOfMonth = {1}, hours = {12}), // monthly meeting\n                    @Schedule(cron = \"*/5 * * * * *\") // every 5 seconds (test)\n            }\n    )\n    void sendInviteNotifications() {\n        LOGGER.log(Level.ALL, \"running scheduled tasks...\");\n        try (ForkJoinPool pool = new ForkJoinPool(\n                Runtime.getRuntime().availableProcessors(),\n                threadFactory,\n                (t, e) -&gt; LOGGER.log(Level.INFO, \"Thread: {0}, error: {1}\", new Object[]{t.getName(), e.getMessage()}),\n                true\n        )) {\n\n            var callables = members.keySet().stream()\n                    .map(\n                            name -&gt; (Callable&lt;Void&gt;) () -&gt; {\n                                LOGGER.info(\"calling invite:\" + name);\n                                notificationService.send(name, members.get(name));\n                                return null;\n                            }\n                    )\n                    .toList();\n\n            var futures = pool.invokeAll(callables)\n                    .stream()\n                    .map(\n                            r -&gt; {\n                                try {\n                                    return CompletableFuture.completedFuture(r.get(100, TimeUnit.MILLISECONDS));\n                                } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                    throw new CompletionException(e);\n                                }\n                            }\n                    )\n                    .toList();\n\n            var result = CompletableFuture.allOf(futures.toArray(CompletableFuture[]::new));\n            result.join();\n        }\n    }\n}\n</code></pre> <p>As you can see, the new <code>@Schedule</code> is currently declared inside the <code>@Asynchronous(runAt = ...)</code> attribute, which some developers find awkward.</p> <p>The <code>NotificationService</code> below is a simple test service used in the example.</p> <pre><code>@ApplicationScoped\npublic class NotificationService {\n    private static final Logger LOGGER = Logger.getLogger(NotificationService.class.getName());\n    private final List&lt;String&gt; names = new CopyOnWriteArrayList&lt;&gt;();\n\n    public void send(String name, String email) {\n        LOGGER.log(Level.INFO, \"sending invite to:[{0}] via {1}\", new Object[]{name, email});\n        this.names.add(name);\n    }\n\n    public List&lt;String&gt; getNames() {\n        return Collections.unmodifiableList(names);\n    }\n\n}\n</code></pre> <p>Create a REST resource that triggers the scheduled tasks:</p> <pre><code>@RequestScoped\n@Path(\"schedule\")\npublic class ScheduleResources {\n\n    @Inject\n    NotificationService notificationService;\n\n    @Inject\n    StandUpMeeting meeting;\n\n    @POST\n    public Response invite() {\n        meeting.sendInviteNotifications();\n        return Response.ok().build();\n    }\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    public List&lt;String&gt; getInvitedNames() {\n        return notificationService.getNames();\n    }\n}\n</code></pre> <p>After deployment, you can trigger notifications with <code>POST /schedule</code> and view invited names with <code>GET /schedule</code>.</p> <p>See the test <code>ScheduleTest</code> for a runnable example: ScheduleTest.</p> <p>Unfortunately, the current <code>@Schedule</code> design has a few rough edges: - It requires an external invocation to trigger scheduled tasks. That means it can not start automatically. see: jakartaee/concurrency#624 - It is expressed as a nested <code>runAt</code> attribute inside <code>@Asynchronous</code>, which some find unintuitive. - Its attributes are not aligned with modern equivalents in frameworks such as Quarkus and Spring. - There is no clear replacement for the legacy timeout callback pattern for handling schedule timeouts.</p> <p>A cleaner, top-level scheduling annotation that adopts community best practices would be preferable. See the proposal for a standalone <code>@Scheduled</code> annotation: https://github.com/jakartaee/concurrency/issues/684</p>"},{"location":"concurrency/#reactive-streams-support","title":"Reactive Streams Support","text":"<p>Jakarta Concurrency 3.1 adds first-class support for the Java 9 <code>Flow</code> (Reactive Streams) API, making it easier to build asynchronous, back-pressured pipelines that interoperate with other reactive libraries.</p> <p>The <code>ContextService</code> contains two helper methods such as <code>contextualSubscriber</code> and <code>contextualProcessor</code>. They are used to wrap standard Flow <code>Subscriber</code> and <code>Processor</code> implementations so they execute with proper Jakarta EE context propagation (CDI, JTA, Security).</p> <p>The example below demonstrates these concepts with a simple chat application that uses CDI events and Server-Sent Events (SSE) to publish messages and Redis as a backing store. A contextual subscriber is used to asynchronously process and count messages.</p> <p>First, define the sample subscriber - <code>RequestCountSubscriber</code>:</p> <pre><code>@ApplicationScoped\npublic class RequestCountSubscriber implements Flow.Subscriber&lt;Long&gt; {\n    private Logger LOGGER = Logger.getLogger(RequestCountSubscriber.class.getName());\n    final public static int MAX_REQUESTS = 2;\n\n    Flow.Subscription subscription;\n    int requestCount = 0;\n\n    @Override\n    public void onSubscribe(Flow.Subscription subscription) {\n        LOGGER.info(\"onSubscribe:\" + subscription);\n        this.subscription = subscription;\n        this.subscription.request(1);\n        this.requestCount++;\n    }\n\n    @Override\n    public void onNext(Long item) {\n        LOGGER.info(\"onNext:\" + item);\n        if (requestCount % MAX_REQUESTS == 0) {\n            this.subscription.request(MAX_REQUESTS);\n        }\n        requestCount++;\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n        LOGGER.info(\"onError:\" + throwable.getMessage());\n        this.subscription.cancel();\n    }\n\n    @Override\n    public void onComplete() {\n        LOGGER.log(Level.INFO, \"onComplete: request count:{0}\", new Object[]{this.requestCount});\n    }\n}\n</code></pre> <p>Next, create a REST resource to publish messages and subscribe the message via SSE:</p> <pre><code>@ApplicationScoped\n@Path(\"chat\")\npublic class ChatResource {\n\n    @Inject\n    ChatService chatService;\n\n    @Context\n    Sse sse;\n\n    @PostConstruct\n    public void init() {\n        chatService.setSse(this.sse);\n    }\n\n    @GET\n    @Produces(MediaType.SERVER_SENT_EVENTS)\n    public void join(@Context SseEventSink sink) {\n        var userId = UUID.randomUUID();\n        chatService.register(userId, sink);\n    }\n\n    @DELETE\n    @Path(\"{id}\")\n    public void quit(@PathParam(\"id\") UUID id) {\n        chatService.deregister(id);\n    }\n\n    @POST\n    @Consumes(MediaType.APPLICATION_JSON)\n    public void send(@Valid NewMessageCommand message) {\n        chatService.send(ChatMessage.of(message.body()));\n    }\n\n    @GET\n    @Path(\"sync\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response latestMessages() {\n        return Response.ok(chatService.latest10Messages()).build();\n    }\n\n    @GET\n    @Path(\"async\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response latestMessagesAsync() {\n        return Response.ok(chatService.latest10MessagesFuture()).build();\n    }\n\n    @GET\n    @Path(\"flow\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Flow.Publisher&lt;ChatMessage&gt; latestMessagesFlow() {\n        return chatService.latest10MessagesFlowPublisher();\n    }\n}\n</code></pre> <p>Finally, implement the <code>ChatService</code> to handle incoming messages, store them in Redis, and use the contextual subscriber to subscribe to them. It is also responsible for sending SSE events to connected clients.    </p> <pre><code>@ApplicationScoped\npublic class ChatService {\n    @Inject\n    private ManagedExecutorService executor;\n\n    @Inject\n    private ContextService contextService;\n\n    @Inject\n    StatefulRedisConnection&lt;String, String&gt; redisConnection;\n\n    @Inject\n    Jsonb jsonb;\n\n    @Inject\n    Logger LOG;\n\n    @Inject\n    RequestCountSubscriber requestCountSubscriber;\n\n    @Inject\n    Event&lt;ChatMessage&gt; chatMessageEvent;\n\n    private Sse sse;\n\n    private final Map&lt;UUID, SseEventSink&gt; sinks = new ConcurrentHashMap&lt;&gt;();\n\n    public void register(UUID id, SseEventSink request) {\n        LOG.log(Level.FINEST, \"register request:{0}\", id);\n        sinks.put(id, request);\n    }\n\n    public void deregister(UUID uuid) {\n        LOG.log(Level.FINEST, \"deregister request:{0}\", uuid);\n        SseEventSink eventSink = sinks.remove(uuid);\n        try {\n            eventSink.close();\n            LOG.log(Level.FINEST, \"closing sink: {0}\", eventSink);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            LOG.log(Level.ALL, \"closed SSE event sink\");\n        }\n    }\n\n    public void send(ChatMessage message) {\n        RedisReactiveCommands&lt;String, String&gt; commands = redisConnection.reactive();\n        commands.lpush(\"chat\", jsonb.toJson(message))\n                .doOnSuccess(\n                        inserted -&gt; {\n                            LOG.log(Level.FINEST, \"inserted items into redis:\" + inserted);\n                            chatMessageEvent.fire(message);\n                        }\n                )\n                .subscribe(\n                        FlowAdapters.toSubscriber(\n                                contextService.contextualSubscriber(requestCountSubscriber)\n                        )\n                );\n    }\n\n    public void onMessage(@Observes ChatMessage msg) {\n        sinks.values()\n                .forEach(sink -&gt; {\n                            OutboundSseEvent outboundSseEvent = this.sse.newEventBuilder()\n                                    .mediaType(MediaType.APPLICATION_JSON_TYPE)\n                                    .id(UUID.randomUUID().toString())\n                                    .name(\"message from cdi\")\n                                    .data(msg)\n                                    .build();\n                            sink.send(outboundSseEvent);\n                        }\n                );\n    }\n\n    public List&lt;ChatMessage&gt; latest10Messages() {\n        RedisCommands&lt;String, String&gt; commands = redisConnection.sync();\n\n        return commands.lpop(\"chat\", 10)\n                .stream()\n                .map(it -&gt; jsonb.fromJson(it, ChatMessage.class))\n                .toList();\n    }\n\n    public CompletableFuture&lt;List&lt;ChatMessage&gt;&gt; latest10MessagesFuture() {\n        RedisAsyncCommands&lt;String, String&gt; commands = redisConnection.async();\n\n        return commands.lpop(\"chat\", 10)\n                .thenApplyAsync(\n                        msg -&gt; msg.stream()\n                                .map(it -&gt; jsonb.fromJson(it, ChatMessage.class))\n                                .toList(),\n                        executor\n                )\n                .toCompletableFuture();\n    }\n\n    public Flow.Publisher&lt;ChatMessage&gt; latest10MessagesFlowPublisher() {\n        RedisReactiveCommands&lt;String, String&gt; commands = redisConnection.reactive();\n\n        Flux&lt;ChatMessage&gt; messageFlux = commands.lpop(\"chat\", 10)\n                .map(it -&gt; jsonb.fromJson(it, ChatMessage.class))\n                .subscribeOn(Schedulers.fromExecutor(executor));\n\n        return FlowAdapters.toFlowPublisher(messageFlux);\n    }\n\n    public void setSse(Sse sse) {\n        this.sse = sse;\n    }\n}\n</code></pre> <p>The RedisConnection bean is defined as follows:</p> <p><pre><code>@ApplicationScoped\npublic class RedisClientProducer {\n    private static final Logger LOGGER = Logger.getLogger(RedisClientProducer.class.getName());\n\n    // Producer method for RedisClient\n    @Produces\n    @ApplicationScoped\n    public RedisClient createRedisClient() {\n        return RedisClient.create(\"redis://localhost:6379\");\n    }\n\n    // Disposer method to close the RedisClient\n    public void closeRedisClient(@Disposes RedisClient redisClient) {\n        LOGGER.finest(\"shutdown redis client...\");\n        redisClient.shutdown();\n    }\n\n    @Produces\n    @ApplicationScoped\n    public StatefulRedisConnection&lt;String, String&gt; redisConnection(RedisClient redisClient) {\n        return redisClient.connect();\n    }\n\n    public void closeConnection(@Disposes StatefulRedisConnection&lt;String, String&gt; redisConnection) {\n        LOGGER.finest(\"closing redis connection...\");\n        redisConnection.close();\n    }\n}\n</code></pre> The <code>NewMessageCommand</code> and <code>ChatMessage</code> classes are simple POJOs:</p> <pre><code>public record NewMessageCommand(\n        @NotBlank String body\n) {\n}\n</code></pre> <pre><code>public record ChatMessage(String body, LocalDateTime sentAt) {\n    static ChatMessage of(String body) {\n        return new ChatMessage(body, LocalDateTime.now());\n    }\n}\n</code></pre> <p>With this setup, messages sent to the chat service are stored in Redis and broadcast to connected clients via SSE. The <code>RequestCountSubscriber</code> processes messages asynchronously, demonstrating Jakarta Concurrency's Reactive Streams support.</p> <p>After deployment, you can interact with the service using the REST endpoints: e.g., <code>GET /chat</code> to join a chat conversation and track the new messages via SSE, <code>POST /chat</code> to send new messages, and <code>GET /chat/sync</code> or <code>GET /chat/async</code> to retrieve the latest 10 messages.</p> <p>[!Warning] Jakarta REST does not yet provide native Flow/Reactive Streams support, so <code>GET /chat/flow</code> may not work reliably on some application servers.</p> <p>See the complete example in this test class: ChatResourceTest.</p>"},{"location":"data/","title":"Meet Jakarta Data: The Newest Member of the Jakarta EE 11 Ecosystem","text":"<p>Jakarta Data is a new specification in Jakarta EE 11 that simplifies data access across different storage technologies. It is storage-agnostic \u2014 not limited to Jakarta Persistence or relational databases \u2014 and is designed so providers can adapt it to a variety of backends. The Eclipse JNoSQL project also implements this specification, bringing the same API surface to the NoSQL ecosystem.</p>"},{"location":"data/#exploring-jakarta-data","title":"Exploring Jakarta Data","text":"<p>Similar to Spring Data Commons, Micronaut Data, and Quarkus Panache, Jakarta Data introduces a <code>Repository</code> abstraction. This includes a basic <code>DataRepository</code> interface to indicate a repository, as well as two interfaces, <code>BasicRepository</code> and <code>CrudRepository</code>, which provide common CRUD operations for underlying data storage. It also introduces a new annotation, <code>@Repository</code>, to mark an interface as a repository, whether it is derived from the common interfaces or is a pure interface that does not extend any existing interface.</p> <p>For example, the following <code>PostRepository</code> interface is for the entity <code>Post</code>.</p> <pre><code>@Repository\npublic interface PostRepository extends CrudRepository&lt;Post, UUID&gt; {\n\n}\n</code></pre> <p>In addition, Jakarta Data supports derived queries by method name conventions, pagination, and custom queries using <code>@Query</code> annotations. If you have experience with Spring Data or Micronaut, you will be familiar with these features.</p> <pre><code>@Repository\npublic interface PostRepository extends CrudRepository&lt;Post, UUID&gt; {\n    Optional&lt;Post&gt; findByTitle(String title);\n\n    Page&lt;Post&gt; findByTitleLike(String titleLike, PageRequest pageRequest);\n\n    @Query(\"where title like :title\")\n    @OrderBy(\"title\")\n    Post[] byTitleLike(@Param(\"title\") String title);\n}\n</code></pre> <p>Additionally, Jakarta Data provides a collection of lifecycle annotations (<code>Find</code>, <code>Insert</code>, <code>Update</code>, <code>Delete</code>) that allow you to write operation methods more freely in your own interfaces. The entity type can be determined from the method parameters or the return type.</p> <pre><code>@Repository\npublic interface Blogger {\n    @Query(\"\"\"\n            SELECT p.id, p.title FROM Post AS p\n            WHERE p.title LIKE :title\n            ORDER BY p.createdAt DESC\n            \"\"\")\n    Page&lt;PostSummary&gt; allPosts(@Param(\"title\") String title, PageRequest page);\n\n    @Find\n    @OrderBy(\"createdAt\")\n    List&lt;Post&gt; byStatus(Status status, Order&lt;Post&gt; order, Limit limit);\n\n    @Find\n    Optional&lt;Post&gt; byId(UUID id);\n\n    @Insert\n    Post insert(Post post);\n\n    @Update\n    Post update(Post post);\n\n    @Delete\n    void delete(Post post);\n}\n</code></pre> <p>Currently, Quarkus and Micronaut have already integrated Jakarta Data as an alternative persistence solution for developers. I have written articles introducing the integration of Jakarta Data with Quarkus and Micronaut. Spring and Spring Data have no plans to integrate Jakarta Data, but that does not mean integrating Jakarta Data with Spring is difficult. I also wrote a post about integrating Hibernate Data Repositories with Spring.</p> <p>Unlike Jakarta Persistence, Spring Data, and Micronaut Data, Jakarta Data 1.0 does not provide specific annotations to define entity types. As a result, it relies heavily on each provider's implementation details. For example, Micronaut Data reuses Jakarta Persistence annotations as well as its own data annotations, both of which work seamlessly with Jakarta Data. Quarkus and WildFly integrate Jakarta Data via Hibernate Data repositories, so in these environments, Jakarta Persistence entities are used to represent Jakarta Data entities.</p> <p>Currently, open-source Jakarta EE implementors such as GlassFish, WildFly, and Open Liberty are working on their own Jakarta Data implementations, typically leveraging entities defined with Jakarta Persistence. However, their approaches vary. WildFly (with Hibernate) translates Jakarta Data queries into Java code and generates repository implementations at compile time. In contrast, GlassFish reuses the effort from Eclipse JNoSQL and dynamically processes queries at runtime.</p> <p>In this post, we\u2019ll focus on demonstrating Jakarta Data features on standard Jakarta EE-compatible application servers, such as GlassFish, WildFly, and others.</p> <p>You can get the example project from my GitHub and explore it yourself.</p>"},{"location":"data/#wildfly","title":"WildFly","text":"<p>WildFly has provided Jakarta Data as a preview feature since version 34. In the latest WildFly 37 preview, Jakarta Data support has been updated to align with Hibernate 7 and Jakarta Persistence 3.2.</p> <p>To use Jakarta Data in WildFly, configure the <code>hibernate-processor</code> in your Maven compiler plugin. This processes your <code>Repository</code> interfaces and generates implementation classes at compile time.</p> <pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;version&gt;${maven-compiler-plugin.version}&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;annotationProcessorPaths&gt;\n            &lt;annotationProcessorPath&gt;\n                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n                &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n                &lt;version&gt;${lombok.version}&lt;/version&gt;\n            &lt;/annotationProcessorPath&gt;\n            &lt;annotationProcessorPath&gt;\n                &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n                &lt;artifactId&gt;hibernate-processor&lt;/artifactId&gt;\n                &lt;version&gt;${hibernate.version}&lt;/version&gt;\n            &lt;/annotationProcessorPath&gt;\n        &lt;/annotationProcessorPaths&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Open a terminal window, navigate to the project root folder, run the following command to compile the project. This will generate repository source code using the configured Hibernate Processor:</p> <pre><code>mvn clean compile -Pwildfly\n</code></pre> <p>The generated repository implementation classes use Hibernate\u2019s <code>StatelessSession</code> to implement all methods. For example, the generated <code>target/generated-sources/annotations/com/example/repository/PostRepository_.java</code> file looks like this:</p> <pre><code>/**\n * Implements Jakarta Data repository {@link com.example.repository.PostRepository}\n **/\n@Dependent\n@Generated(\"org.hibernate.processor.HibernateProcessor\")\npublic class PostRepository_ implements PostRepository {\n    protected @Nonnull StatelessSession session;\n\n    public PostRepository_(@Nonnull StatelessSession session) {\n        this.session = session;\n    }\n\n    public @Nonnull StatelessSession session() {\n        return session;\n    }\n\n    @PersistenceUnit\n    private EntityManagerFactory sessionFactory;\n\n    @PostConstruct\n    private void openSession() {\n        session = sessionFactory.unwrap(SessionFactory.class).openStatelessSession();\n    }\n\n    @PreDestroy\n    private void closeSession() {\n        session.close();\n    }\n\n    @Inject\n    PostRepository_() {\n    }\n\n    //... other methods\n    /**\n     * Find {@link Post}.\n     *\n     * @see com.example.repository.PostRepository#findAll(PageRequest,Order)\n     **/\n    @Override\n    public Page&lt;Post&gt; findAll(PageRequest pageRequest, Order&lt;Post&gt; sortBy) {\n        var _builder = session.getCriteriaBuilder();\n        var _query = _builder.createQuery(Post.class);\n        var _entity = _query.from(Post.class);\n        _query.where(\n        );\n        var _spec = SelectionSpecification.create(_query);\n        for (var _sort : sortBy.sorts()) {\n            _spec.sort(asc(Post.class, _sort.property())\n                        .reversedIf(_sort.isDescending())\n                        .ignoringCaseIf(_sort.ignoreCase()));\n        }\n        try {\n            long _totalResults =\n                    pageRequest.requestTotal()\n                            ? _spec.createQuery(session)\n                                    .getResultCount()\n                            : -1;\n            var _results = _spec.createQuery(session)\n                .setFirstResult((int) (pageRequest.page()-1) * pageRequest.size())\n                .setMaxResults(pageRequest.size())\n                .getResultList();\n            return new PageRecord&lt;&gt;(pageRequest, _results, _totalResults);\n        }\n        catch (PersistenceException _ex) {\n            throw new DataException(_ex.getMessage(), _ex);\n        }\n    }\n}\n</code></pre> <p>To run the project on a managed WildFly server, execute the following command:</p> <pre><code>mvn clean package wildfly:run -Pwildfly\n</code></pre> <p>You can find Jakarta Data usage examples in the testing codes.</p> <p>The tests are written with Arquillian and JUnit 5, to run the tests on the managed WildFly with the Arquillian WildFly adapter:</p> <pre><code>mvn clean verify -Parq-wildfly-managed\n</code></pre>"},{"location":"data/#glassfish","title":"GlassFish","text":"<p>Since GlassFish 8.0.0-M14, initial Jakarta Data support has been included. But unfortunately, I still encountered some issues running these examples on GlassFish. </p> <p>Firstly, we used a query result projection to a Record class for <code>Blogger.allPosts</code>, which is a preview feature of the future Jakarta Data 1.1. It is not available in GlassFish. We have to change it to use an entity class in the return type or wrapped type.</p> <pre><code>@Repository\npublic interface Blogger {\n    @Query(\"\"\"\n            SELECT p FROM Post AS p\n            WHERE p.title LIKE :title\n            ORDER BY p.createdAt DESC\n            \"\"\")\n    Page&lt;Post&gt; allPosts(@Param(\"title\") String title, PageRequest page);\n\n}\n</code></pre> <p>Unlike WildFly, which generates implementation code at compile time via the Hibernate processor, the Jakarta Data implementation on GlassFish is provided by the JNoSQL extension JNoSQL Jakarta Persistence, which handles Jakarta Data facilities at runtime.</p> <p>To run the project on a managed GlassFish server, execute the following command:</p> <pre><code>mvn clean package cargo:run -Pglassfish\n</code></pre> <p>To run the integration tests on a managed GlassFish server with the Arquillian GlassFish adapter, execute the following command:</p> <pre><code>mvn clean verify -Parq-glassfish-managed\n</code></pre> <p>[!NOTE] Currently, several tests are still failing because some fixes from the upstream JNoSQL Jakarta Persistence project have not been applied to the GlassFish repository. I have created some GitHub issues for the GlassFish project to track future updates.  </p>"},{"location":"el/","title":"Jakarta Expression Language","text":"<p>Jakarta Expression Language 6.0 removes the dependency on <code>SecurityManager</code> and several deprecated APIs. It also introduces a number of notable improvements for developers:</p> <ul> <li>Arrays now support a new <code>length</code> property.</li> <li>Introduces support for <code>java.lang.Record</code> through the new <code>RecordELResolver</code>, which is enabled by default.</li> <li>Adds support for <code>java.lang.Optional</code> via the new <code>OptionalELResolver</code>, which is disabled by default.</li> </ul>"},{"location":"faces/","title":"Jakarta Faces","text":"<p>Jakarta Faces, previously known as Jakarta Server Faces and JavaServer Faces (JSF), is a Java specification designed for creating component-based user interfaces for web applications. It includes features such as UI components, state management, event handling, input validation, page navigation, and support for internationalization and accessibility.</p>"},{"location":"jpa/","title":"What's New in Jakarta Persistence 3.2","text":"<p>The Jakarta Persistence API (JPA) is the standard for persistence and object-relational mapping in Java environments. It provides a straightforward API for executing queries using the Jakarta Persistence Query Language (JPQL), as well as an alternative Criteria API for constructing type-safe queries in Java code.</p> <p>As a minor upgrade, Jakarta Persistence 3.2 adds numerous enhancements and new features. For a comprehensive list, see the Jakarta Persistence 3.2 specification page.</p>"},{"location":"jpa/#jpql-improvements","title":"JPQL Improvements","text":"<p>Jakarta Persistence 3.2 refines the Jakarta Persistence Query Language (JPQL), introducing new syntax and porting several SQL functions.</p>"},{"location":"jpa/#queries-without-a-select-clause","title":"Queries Without a Select Clause","text":"<p>This feature, long available in Hibernate, is now standardized in Jakarta Persistence 3.2:</p> <pre><code>em.createQuery(\"from Book where name like '%Hibernate'\", Book.class)\n    .getResultStream()\n    .forEach(book -&gt; LOG.debug(\"query result without select:{}\", book));\n</code></pre> <p>Here, the <code>select</code> keyword is omitted. The query in the above code is equivalent to the following classic form:</p> <pre><code>select b from Book b ...\n</code></pre>"},{"location":"jpa/#new-functions-idthis-countthis-versionthis","title":"New Functions: <code>id(this)</code>, <code>count(this)</code>, <code>version(this)</code>","text":"<p>Jakarta Persistence 3.2 introduces the functions <code>id(this)</code>, <code>count(this)</code>, and <code>version(this)</code>, allowing you to query an entity's ID, count, and version, respectively:</p> <pre><code>// count book entity\nvar count = em.createQuery(\"select count(this) from Book\")\n    .getSingleResult();\nLOG.debug(\"count(this) result: {}\", count);\n\n// id and version\nem.createQuery(\"select id(this), version(this) from Book\", Object[].class)\n    .getResultList()\n    .forEach(book -&gt; LOG.debug(\"id and version result: {}\", book));\n</code></pre>"},{"location":"jpa/#string-concatenation","title":"String Concatenation","text":"<p>In 3.2, JPQL now supports SQL-style string concatenation using <code>||</code>:</p> <pre><code>// Query books where the author's name matches the person's first and last name\nem.createQuery(\"\"\"\n        select b from Book b cross join Person c\n        where b.author.name = c.firstName || ' ' || c.lastName\n          and c.firstName = :firstName\n          and c.lastName = :lastName\n        \"\"\", Book.class)\n    .setParameter(\"firstName\", \"Gavin\")\n    .setParameter(\"lastName\", \"King\")\n    .getResultStream()\n    .forEach(book -&gt; LOG.debug(\"author name equals person name: {}\", book));\n</code></pre>"},{"location":"jpa/#null-handling-in-the-order-by-clause","title":"Null Handling in the <code>ORDER BY</code> Clause","text":"<p>The <code>nulls first</code> and <code>nulls last</code> features, previously available only in SQL, are now supported in JPQL:</p> <pre><code>em.createQuery(\"from Book order by name nulls first\", Book.class)\n    .getResultStream()\n    .forEach(book -&gt; LOG.debug(\"sorted with nulls first: {}\", book));\n</code></pre> <p>This query ensures that results with <code>null</code> in the <code>name</code> field appear first.</p>"},{"location":"jpa/#additional-sql-functions-left-right-cast-replace","title":"Additional SQL Functions: <code>left</code>, <code>right</code>, <code>cast</code>, <code>replace</code>","text":"<p>Standard SQL functions such as <code>left</code>, <code>right</code>, <code>cast</code>, and <code>replace</code> are now available in JPQL, reducing the need to fall back to native queries:</p> <pre><code>em.createQuery(\"\"\"\n        select left(name, 5),\n               right(name, 2),\n               cast(price as Integer),\n               replace(name, ' ', '_'),\n               name\n        from Book\n        \"\"\", Object[].class)\n    .getResultStream()\n    .forEach(book -&gt; LOG.debug(\"new functions result: {}\", java.util.Arrays.toString(book)));\n</code></pre>"},{"location":"jpa/#set-operations-union-intersect-and-except","title":"Set Operations: <code>union</code>, <code>intersect</code>, and <code>except</code>","text":"<p>Several set operators in SQL, such as <code>union</code>, <code>intersect</code>, and <code>except</code>, have also been introduced in JPQL. These operators allow you to combine, compare, or subtract the results of two or more SELECT queries, treating the results as mathematical sets. Let\u2019s examine some examples to illustrate their usage.</p> <p>The following query combines person full names and book author names, returning a distinct list of all names.</p> <pre><code>// query union book name and person name\nem.createQuery(\"\"\"\n            select c.firstName ||' '|| c.lastName from Person c\n            union\n            select b.author.name  from Book b\n            \"\"\", String.class)\n    .getResultStream()\n    .forEach(name -&gt; LOG.debug(\"query union book name and person name: {}\", name));\n</code></pre> <p>This query returns names that exist both as person full names and book author names.</p> <pre><code>// intersect book name and person name\nem.createQuery(\"\"\"\n            select c.firstName ||' '|| c.lastName from Person c\n            intersect\n            select b.author.name  from Book b\n            \"\"\", String.class)\n    .getResultStream()\n    .forEach(name -&gt; LOG.debug(\"intersect book name and person name: {}\", name));\n</code></pre> <p>This query returns the person's full names that are not the book author's names.</p> <pre><code>// except book name and person name\nem.createQuery(\"\"\"\n            select c.firstName ||' '|| c.lastName from Person c\n            except\n            select b.author.name  from Book b\n            \"\"\", String.class)\n    .getResultStream()\n    .forEach(name -&gt; LOG.debug(\"except book name and person name: {}\", name));\n</code></pre> <p>While we've covered the exciting changes to JPQL syntax, it's worth noting that all these enhancements are also fully supported by the Criteria API. This means you can harness the power of these new features using type-safe Java code, adding another layer of robustness to your queries. The Criteria API also introduces subtle improvements, such as the introduction of the new <code>CriteriaSelect</code> interface, further streamlining query construction.</p>"},{"location":"jpa/#new-criteriaselect-interface","title":"New <code>CriteriaSelect</code> Interface","text":"<p>The new <code>CriteriaSelect</code> interface is a top-level interface designed to represent a united general-purpose query, including <code>union</code> and <code>intersect</code> operations.</p> <p>Let's convert the former JPQL <code>union</code> query example into a type-safe Criteria API equivalent:  </p> <pre><code>CriteriaBuilder cb = em.getCriteriaBuilder();\n\n// First part of the union: select c.firstName || ' ' || c.lastName from Person c\nCriteriaQuery&lt;String&gt; personQuery = cb.createQuery(String.class);\nRoot&lt;Person&gt; personRoot = personQuery.from(Person.class);\npersonQuery.select(cb.concat(List.of(personRoot.get(Person_.FIRST_NAME), cb.literal(\" \"), personRoot.get(Person_.LAST_NAME))));\n\n// Second part of the union: select b.author.name from Book b\nCriteriaQuery&lt;String&gt; bookQuery = cb.createQuery(String.class);\nRoot&lt;Book&gt; bookRoot = bookQuery.from(Book.class);\nbookQuery.select(bookRoot.get(\"author\").get(\"name\"));\n\n// Combine the two queries with UNION\n// Jakarta Persistence 3.2 adds union() to CriteriaBuilder\nCriteriaSelect&lt;String&gt; unionQuery = cb.union(personQuery, bookQuery);\n\nem.createQuery(unionQuery)\n        .getResultStream()\n        .forEach(name -&gt; LOG.info(\"query union book name and person name: \" + name));\n</code></pre> <p>As you can see, when you combine two queries using <code>CriteriaBuilder.union(...)</code>, the method now returns a <code>CriteriaSelect</code> object, not a <code>CriteriaQuery</code>. This <code>CriteriaSelect</code> acts as the parent interface for the existing <code>CriteriaQuery</code>, providing a unified way to manage these set operations.</p>"},{"location":"jpa/#entity-mapping-improvements","title":"Entity Mapping Improvements","text":"<p>Jakarta Persistence 3.2 introduces several enhancements to the Entity classes mappings.</p>"},{"location":"jpa/#package-level-generator-definitions","title":"Package-Level Generator Definitions","text":"<p>Before 3.2, when using <code>SequenceGenerator</code> or <code>TableGenerator</code>, you had to declare them with <code>@GeneratedValue</code> in the entity classes like this. </p> <pre><code>@Entity\npublic class Post {\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator=\"blog_seq\")\n    @SequenceGenerator(name = \"blog_seq\", initialValue = 1, allocationSize = 10)\n    private Long id;\n    // ...\n}\n</code></pre> <p>It could be tedious to set up in every class.</p> <p>Starting with version 3.2, Jakarta Persistence allows you to define identity generators at the package level. When a generator is declared in a <code>package-info.java</code> file, it will be automatically applied to all entity classes within that package according to generator types.</p> <p>For example, you can declare generators as follows in your <code>package-info.java</code>:</p> <pre><code>@SequenceGenerator(name = \"blog_seq\", initialValue = 1, allocationSize = 10)\n@TableGenerator(\n    name = \"tbl_id_gen\",\n    table = \"id_gen\",\n    pkColumnName = \"gen_key\",\n    pkColumnValue = \"id\",\n    valueColumnName = \"gen_val\",\n    allocationSize = 10\n)\npackage com.example.blog;\n\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.persistence.TableGenerator;\n</code></pre> <p>Once defined, your entity classes can reference these generators:</p> <pre><code>@Entity\npublic class Post {\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE)\n    private Long id;\n    // ...\n}\n\n@Entity\npublic class Comment {\n    @Id\n    @GeneratedValue(strategy = GenerationType.TABLE, generator = \"tbl_id_gen\")\n    private Long id;\n    // ...\n}\n</code></pre> <p>The persistence provider will automatically discover the generators defined in <code>package-info.java</code> and apply them to the corresponding entities.</p>"},{"location":"jpa/#ongoing-java-8-datetime-api-enhancements","title":"Ongoing Java 8 DateTime API Enhancements","text":"<p>Before 3.2, Java 8 DateTime APIs were already supported in Jakarta Persistence as alternatives to the legacy Date types from the <code>java.util</code> and <code>java.sql</code> packages. </p> <p>Starting with version 3.2, the support for legacy <code>Date</code>, <code>Calendar</code>, <code>Time</code>, and <code>java.sql.Date</code> types is now deprecated. It is recommended to use the modern Java 8 DateTime API instead when starting a new project.</p> <p>Additionally, <code>Instant</code> and <code>Year</code> are now supported as basic types:</p> <pre><code>class Book {\n    Instant createdAt;\n    Year publicationYear;\n}\n</code></pre> <p>Version 3.2 also introduces support for using <code>LocalDateTime</code> and <code>Instant</code> as the entity version type:</p> <pre><code>class Book {\n    @Version\n    Instant version;\n}\n</code></pre> <p>With the deprecation of the legacy date types, annotations such as <code>@Temporal</code> are also deprecated in 3.2.</p>"},{"location":"jpa/#new-attributes-in-column-annotation","title":"New Attributes in <code>@Column</code> Annotation","text":"<p>Jakarta Persistence 3.2 introduces two new attributes to the <code>@Column</code> annotation: <code>comment</code> and <code>check</code>, offering richer schema generation capabilities.</p> <pre><code>@Entity\nclass Post {\n\n    @Column(\n        name = \"title\",\n        nullable = false,\n        length = 100,\n        unique = true,\n        comment = \"Post title\",\n        check = @CheckConstraint(\n            name = \"title_min_length\",\n            constraint = \"length(title) &gt; 10\"\n        )\n    )\n    private String title;\n\n    // ...\n}\n</code></pre> <p>The new <code>check</code> attribute allows you to define check constraints at the column level, which will be reflected in the generated database schema:</p> <pre><code>title VARCHAR(100) NOT NULL UNIQUE /* Post title */ CHECK (length(title) &gt; 10)\n</code></pre> <p>Another improvement in 3.2 is the <code>secondPrecision</code> attribute, which can be set on temporal columns to control the precision of persisted timestamp values. This is particularly useful for ensuring consistency across different persistence providers and various databases.</p> <pre><code>@Column(name = \"created_at\", secondPrecision = 3)\nprivate Instant createdAt;\n</code></pre> <p>This addresses previous issues where different JPA providers handled timestamp precision inconsistently. For example, I encountered this while contributing to Eclipse Cargo Tracker.</p>"},{"location":"jpa/#customizing-enum-mapping-with-enumeratedvalue","title":"Customizing Enum Mapping with <code>@EnumeratedValue</code>","text":"<p>Before 3.2, Java enum types could only be mapped using their name or ordinal value with the <code>@Enumerated</code> annotation:</p> <pre><code>@Entity\nclass Post {\n    @Enumerated(EnumType.STRING)\n    private ModerationStatus status;\n    // ...\n}\n\npublic enum ModerationStatus {\n    PENDING,\n    APPROVED,\n    REJECTED\n}\n</code></pre> <p>In 3.2, it introduces a new annotation - <code>@EnumeratedValue</code>, which allows you to specify a custom field of the Enum type to be persisted:</p> <pre><code>@Entity\nclass Post {\n    private ModerationStatus status;\n    // ...\n}\n\npublic enum ModerationStatus {\n    PENDING(0),\n    APPROVED(1),\n    REJECTED(-1);\n\n    @EnumeratedValue\n    private final int value;\n\n    ModerationStatus(int value) {\n        this.value = value;\n    }\n}\n</code></pre> <p>Now, it will store the field value marked with <code>@EnumeratedValue</code> instead of the enum name or ordinal.</p>"},{"location":"jpa/#record-types-as-embeddables","title":"Record Types as Embeddables","text":"<p>Java record type support is a significant addition in Jakarta EE 11. With Jakarta Persistence 3.2, Java records are now fully supported and can be used as <code>@Embeddable</code> types. For more details, please move on to the dedicated Java Record Support in Jakarta EE 11 document.</p>"},{"location":"jpa/#api-enhancements","title":"API Enhancements","text":"<p>Several minor developer-oriented improvements have been added to the <code>EntityManager</code> and <code>Query</code>, which will enhance development productivity.</p>"},{"location":"jpa/#programmatic-configuration","title":"Programmatic Configuration","text":"<p>Before version 3.2, in a Java SE environment, creating an <code>EntityManagerFactory</code> required a persistence.xml file placed in the <code>src/main/resources/META-INF</code> directory of your project.</p> <p>Here is an example of a persistence.xml:</p> <pre><code>&lt;persistence xmlns=\"https://jakarta.ee/xml/ns/persistence\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_2.xsd\"\n             version=\"3.2\"&gt;\n\n    &lt;persistence-unit name=\"bookstorePU\" transaction-type=\"RESOURCE_LOCAL\"&gt;\n\n        &lt;description&gt;Hibernate test case template Persistence Unit&lt;/description&gt;\n        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;\n\n        &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;\n\n        &lt;properties&gt;\n            &lt;property name=\"hibernate.archive.autodetection\" value=\"class, hbm\"/&gt;\n            &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.H2Dialect\"/&gt;\n            &lt;property name=\"hibernate.connection.driver_class\" value=\"org.h2.Driver\"/&gt;\n            &lt;property name=\"hibernate.connection.url\" value=\"jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1\"/&gt;\n            &lt;property name=\"hibernate.connection.username\" value=\"sa\"/&gt;\n        &lt;/properties&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre> <p>Then you can create an <code>EntityManagerFactory</code> instance like this:</p> <pre><code>var emf = Persistence.createEntityManagerFactory(\"bookstorePU\");\n</code></pre> <p>With Jakarta Persistence 3.2, the new <code>PersistenceUnitConfiguration</code> allows you to set up these properties programmatically using the builder-style pattern:</p> <pre><code>PersistenceConfiguration configuration = new PersistenceConfiguration(\"bookstore\")\n    .transactionType(PersistenceUnitTransactionType.RESOURCE_LOCAL)\n    .provider(HibernatePersistenceProvider.class.getName())\n    // .nonJtaDataSource(\"java:global/jdbc/BookstoreData\")\n    .managedClass(Book.class)\n    .managedClass(Isbn.class)\n    .managedClass(Author.class)\n    .property(PersistenceConfiguration.LOCK_TIMEOUT, 5000)\n    .property(\"hibernate.type.prefer_java_type_jdbc_types\", true)\n    .property(\"hibernate.hbm2ddl.auto\", \"create-drop\")\n    .property(PersistenceConfiguration.JDBC_URL, \"jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1\")\n    .property(PersistenceConfiguration.JDBC_DRIVER, \"org.h2.Driver\")\n    .property(PersistenceConfiguration.JDBC_USER, \"sa\");\n</code></pre> <p>Then you can create an <code>EntityManagerFactory</code> instance using the following method:</p> <pre><code>var emf = configuration.createEntityManagerFactory();\n</code></pre> <p>Or using the new <code>Persistence.createEntityManagerFactory</code> method variant, which accepts a <code>PersistenceConfiguration</code> parameter:</p> <pre><code>var emf = Persistence.createEntityManagerFactory(configuration);\n</code></pre>"},{"location":"jpa/#schema-management","title":"Schema Management","text":"<p>Before version 3.2, you could configure using script files, entities, or both to manage database schema generation at runtime. </p> <p>In the following example, we configure the schema-generation action and export the database schema using properties in persistence.xml:</p> <pre><code>&lt;persistence ...&gt;\n    &lt;persistence-unit&gt;\n        &lt;properties&gt;\n            &lt;property name=\"jakarta.persistence.schema-generation.scripts.action\" value=\"drop-and-create\" /&gt;\n            &lt;property name=\"jakarta.persistence.schema-generation.scripts.create-target\" value=\"/tmp/create.ddl\" /&gt;\n            &lt;property name=\"jakarta.persistence.schema-generation.scripts.drop-target\" value=\"/tmp/drop.ddl\" /&gt;\n        &lt;/properties&gt;\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre> <p>You could then use the <code>Persistence.generate(String persistenceUnit, Map&lt;String, Object&gt; properties)</code> method to generate schema scripts at the specified target paths.</p> <p>Jakarta Persistence 3.2 introduces the new <code>SchemaManager</code>, which allows you to validate, create, drop, and truncate the database schema according to the existing persistence configuration:</p> <pre><code>emf.getSchemaManager().validate();\nemf.getSchemaManager().truncate();\nemf.getSchemaManager().drop(true);    // if true, applies changes to the database\nemf.getSchemaManager().create(true);  // if true, applies changes to the database\n</code></pre> <p>The <code>truncate</code> method could help reset the database when writing test code.</p> <p>[!Note] The <code>SchemaManager</code> does not support exporting the schema to DDL script files.</p> <p>And unfortunately, in 3.2, the <code>Persistence.generate</code> does not involve a variant and accepts a <code>PersistenceConfiguration</code> parameter (i.e., <code>Persistence.generate(PersistenceConfiguration)</code> does not exist).</p>"},{"location":"jpa/#functional-transactions","title":"Functional Transactions","text":"<p>Before 3.2, you could control the transaction boundaries manually as follows:</p> <pre><code>EntityTransaction tx = em.getTransaction();\ntx.begin();\ntry {\n    // ...\n    em.persist(entity);\n    tx.commit();\n} catch (Exception e) {\n    tx.rollback();\n}\n</code></pre> <p>Jakarta Persistence 3.2 introduces two new methods, <code>runInTransaction</code> and <code>callInTransaction</code>, on <code>EntityManagerFactory</code>, which allow you to execute logic within a transactional context.</p> <p>The following is an example of using <code>runInTransaction</code> to persist a <code>Book</code> entity, and there is no need to return a result. It is suitable for mutating operations such as insert, update, or delete.</p> <pre><code>emf.runInTransaction(em -&gt; {\n    Book entity = new Book(\n        new Isbn(\"9781932394887\"),\n        \"Java Persistence with Hibernate\",\n        new Author(\"Gavin King\"),\n        new BigDecimal(\"50.1234\")\n    );\n    em.persist(entity);\n    LOG.debug(\"persisted book: {}\", entity);\n});\n</code></pre> <p>Alternatively, the <code>callInTransaction</code> method is designed for cases that require returning a result after the logic is executed. It is ideal for selection queries.</p> <pre><code>emf.callInTransaction(em -&gt; em.createQuery(\"from Book\", Book.class)\n                             .getResultList())\n    .forEach(book -&gt; LOG.debug(\"saved book: {}\", book));\n</code></pre> <p>With these methods, you no longer need to control transactions explicitly, such as begin, commit, and rollback. Every execution block automatically participates in an active transaction context. </p> <p>Additionally, the <code>EntityManager</code> adds two similar methods: <code>runWithConnection</code> and <code>callWithConnection</code>, which bind database operations to an immutable <code>Connection</code> abstraction. Typically, for the databases using JDBC, these methods let you work with a JDBC <code>Connection</code> object.</p> <p>Here\u2019s how to use <code>runWithConnection</code>:</p> <pre><code>em.runWithConnection(conn -&gt; {\n    var rs = conn.prepareStatement(\"select * from posts\").executeQuery();\n    while (rs.next()) {\n        LOG.debug(\"query result:\");\n        LOG.debug(\"id: {}\", rs.getLong(\"id\"));\n        LOG.debug(\"title: {}\", rs.getString(\"title\"));\n        LOG.debug(\"content: {}\", rs.getString(\"content\"));\n    }\n});\n</code></pre> <p>This method is transaction-aware and joins any existing transaction. You don\u2019t need to manage transactions and care about the lifecycle of the incoming Connection object. Do not try to close the <code>Connection</code> yourself inside the block.</p>"},{"location":"jpa/#type-safe-options","title":"Type-Safe Options","text":"<p>In Jakarta Persistence 3.2, the 'EntityManager' overloads methods such as <code>find</code>, <code>refresh</code>, and <code>lock</code> to accept type-safe <code>FindOption</code>, <code>RefreshOption</code>, and <code>LockOption</code> respectively, replacing the previous use of a generic <code>Map&lt;String, Object&gt;</code> properties.</p> <p>Before 3.2, you could tune the <code>find</code> method with a general <code>Map</code> parameter.</p> <pre><code>// Using a Map for query hints and options\nvar book = em.find(Book.class, new Isbn(\"9781932394887\"),\n        Map.of(\"jakarta.persistence.cache.retrieveMode\", CacheRetrieveMode.BYPASS,\n               \"jakarta.persistence.query.timeout\", 500,\n               \"org.hibernate.readOnly\", true)\n);\nLOG.debug(\"Found book using Map-based options: {}\", book);\n</code></pre> <p>In 3.2, you can use the type-safe options instead. </p> <pre><code>// Using type-safe options\nvar result = em.find(Book.class, new Isbn(\"9781932394887\"),\n        CacheRetrieveMode.BYPASS,\n        Timeout.seconds(500),\n        LockModeType.READ);\nLOG.debug(\"Found book using type-safe options: {}\", result);\n</code></pre> <p>Besides these, the generated static metamodel includes strongly typed constants for named queries, entity graphs, result set mappings, and managed types, thereby minimizing typos and making refactoring safer.</p> <p>Suppose you have the following entity:</p> <pre><code>@NamedQuery(name = \"byTitle\", query = \"SELECT p FROM Post p WHERE p.title = :title\")\n@NamedEntityGraph(\n        name = \"withComments\",\n        attributeNodes = {\n                @NamedAttributeNode(\"title\"),\n                @NamedAttributeNode(\"content\"),\n                @NamedAttributeNode(value = \"comments\", subgraph = \"commentsGraph\"),\n                @NamedAttributeNode(\"createdAt\")\n        },\n        subgraphs = @NamedSubgraph(\n                name = \"commentsGraph\",\n                attributeNodes = @NamedAttributeNode(\"content\")\n        )\n)\npublic class Post { ... }\n</code></pre> <p>After compilation, the generated <code>Post_</code> metamodel class will contain constants for the named query <code>byTitle</code> and named entity graph <code>withComments</code>:</p> <pre><code>public abstract class Post_ {\n    // ...\n    public static final String QUERY_BY_TITLE = \"byTitle\";\n    public static final String GRAPH_WITH_COMMENTS = \"withComments\";\n}\n</code></pre> <p>Then you can use the constants for queries and entity graphs to replace the former literal text.</p> <pre><code>// Referencing the named query using the metamodel constant\nvar result = em.createNamedQuery(Post_.QUERY_BY_TITLE, Post.class)\n        .setParameter(\"title\", \"What's new in Persistence 3.2?\")\n        .getSingleResult();\nLOG.debug(\"Query byTitle result: {}\", result);\n\n// Referencing the named entity graph using the metamodel constant\nPost result2 = em.find(Post.class, entity.getId(),\n        em.getEntityGraph(Post_.GRAPH_WITH_COMMENTS));\nLOG.debug(\"Query withComments result: {}\", result2.getComments());\n</code></pre> <p>You can also refer to attribute names via constants in the static metamodel in relationship mappings:</p> <pre><code>@Entity\npublic class Post {\n    // ...\n    @OneToMany(mappedBy = Comment_.POST,\n            fetch = FetchType.LAZY,\n            cascade = CascadeType.ALL,\n            orphanRemoval = true\n    )\n    private Set&lt;Comment&gt; comments = new HashSet&lt;&gt;();\n}\n</code></pre> <p>This approach ensures type safety and helps avoid errors caused by hard-coded string references.</p>"},{"location":"jpa/#new-method-getsingleresultornull-in-query","title":"New Method <code>getSingleResultOrNull</code> in <code>Query</code>","text":"<p>Before version 3.2, the <code>getSingleResult</code> method would return the single unique result if it existed. Otherwise, it would throw a <code>NoResultException</code>. </p> <p>To return <code>null</code> instead of throwing exceptions, you had to write something like:</p> <pre><code>try {\n   return query.getSingleResult();\n} catch (NoResultException e) {\n   return null;\n}\n</code></pre> <p>Jakarta Persistence 3.2 solves this by introducing the new <code>getSingleResultOrNull</code> method to <code>Query</code> and its derived interfaces, including <code>TypedQuery&lt;T&gt;</code>, among others. This method returns <code>null</code> directly when no result is found.</p> <p>Here is an example using <code>getSingleResultOrNull</code>:</p> <pre><code>var nullableResult = em.createQuery(\"from Book where id = :isbn\", Book.class)\n        .setParameter(\"isbn\", new Isbn(\"9781932394887\"))\n        .getSingleResultOrNull();\nLOG.debug(\"book getSingleResultOrNull result: {}\", nullableResult);\n</code></pre> <p>Now you never have to worry about catching a <code>NoResultException</code>.</p> <p>[!Note] When representing the presence or absence of a single result, I would prefer to use <code>Optional&lt;T&gt;</code> to align with modern Java best practices. See the issue: jakartaee/persistence#479.</p>"},{"location":"jpa/#new-method-getreferencet-in-entitymanager","title":"New Method <code>getReference(T)</code> in <code>EntityManager</code>","text":"<p>As an alternative to the existing <code>getReference(Class, id)</code>, the new method provides a way to obtain a reference to an entity using a given object with the same primary key. The supplied object may be in a managed or detached state, but it must not be new or removed.</p> <p>This method is beneficial when you need to set an association using detached entity instances, for example:</p> <pre><code>var post = ...\n// The session is closed here, so the `post` instance is now detached\n\n// In a new session\ncomment.setPost(em.getReference(post));\n// Persist the comment and close the session\n</code></pre> <p>This approach avoids the need to fetch the post entity from the database again.</p> <p>Here, we highlight the API improvements in Jakarta Persistence 3.2 that offer tangible benefits to application developers. While there are many other minor enhancements not covered here, you can find the complete list of changes in the Jakarta Persistence 3.2 specification.</p>"},{"location":"jpa/#jakarta-ee-integration","title":"Jakarta EE Integration","text":"<p>In Jakarta EE environments, before 3.2, you should use <code>@PersistenceContext</code> to inject an <code>EntityManager</code> bean that matches the default persistence unit definition in the persistence.xml file:</p> <pre><code>@PersistenceContext\nprivate EntityManager em;\n</code></pre> <p>When it comes to 3.2, you no longer need to use <code>@PersistenceUnit</code> or <code>@PersistenceContext</code> to inject <code>EntityManagerFactory</code> or <code>EntityManager</code> in the Jakarta EE components. Instead, you can use standard CDI <code>@Inject</code> to inject them like injecting regular CDI beans.</p> <pre><code>@Inject\nprivate EntityManager em;\n</code></pre> <p>Jakarta Persistence 3.2 also allows you to specify <code>scope</code> and <code>qualifier</code> elements in your persistence.xml file, making it easier to control the lifecycle and selection of persistence units in CDI.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;persistence version=\"3.2\" xmlns=\"https://jakarta.ee/xml/ns/persistence\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_2.xsd\"&gt;\n    &lt;persistence-unit name=\"defaultPU\" transaction-type=\"JTA\"&gt;\n        &lt;qualifier&gt;com.example.employee.MyCustom&lt;/qualifier&gt;\n        &lt;scope&gt;jakarta.enterprise.context.ApplicationScoped&lt;/scope&gt;\n        &lt;jta-data-source&gt;java:comp/DefaultDataSource&lt;/jta-data-source&gt;\n        ...\n    &lt;/persistence-unit&gt;\n&lt;/persistence&gt;\n</code></pre> <p>Here, <code>MyCustom</code> is a custom CDI <code>@Qualifier</code> annotation:</p> <pre><code>@Documented\n@Retention(RUNTIME)\n@Qualifier\npublic @interface MyCustom {\n}\n</code></pre> <p>Then you can inject the qualified <code>EntityManager</code> or <code>EntityManagerFactory</code> as follows:</p> <pre><code>@Inject @MyCustom\nprivate EntityManager em;\n</code></pre>"},{"location":"jpa/#example-projects","title":"Example Projects","text":"<p>All sample code referenced in this guide is available on GitHub. You can explore and try it out for yourself.</p>"},{"location":"jpa/#hibernate-example-project","title":"Hibernate Example Project","text":"<p>You can find the Hibernate example here: https://github.com/hantsy/jakartaee11-sandbox/tree/master/hibernate, which demonstrates running Jakarta Persistence code in the Java SE environment.</p> <p>Check out the source code, and import the project into your favorite IDE.</p> <p>Open the pom.xml file, and you will see the project includes Hibernate ORM and the Jakarta Persistence API dependencies:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n    &lt;version&gt;${hibernate.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n    &lt;artifactId&gt;hibernate-scan-jandex&lt;/artifactId&gt;\n    &lt;version&gt;${hibernate.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;\n    &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;\n    &lt;version&gt;3.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>To generate static metamodel classes for your entities at compile time, you should add <code>hibernate-processor</code> to the <code>annotationProcessorPaths</code> section of the <code>maven-compiler-plugin</code> configuration:</p> <pre><code>&lt;plugins&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${maven-compiler-plugin.version}&lt;/version&gt;\n        &lt;configuration&gt;\n            &lt;annotationProcessorPaths&gt;\n                &lt;annotationProcessorPath&gt;\n                    &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;\n                    &lt;artifactId&gt;hibernate-processor&lt;/artifactId&gt;\n                    &lt;version&gt;${hibernate.version}&lt;/version&gt;\n                &lt;/annotationProcessorPath&gt;\n            &lt;/annotationProcessorPaths&gt;\n        &lt;/configuration&gt;\n    &lt;/plugin&gt;\n&lt;/plugins&gt;\n</code></pre> <p>You can just run the test code in the IDE directly to see Jakarta Persistence 3.2 features in action.</p>"},{"location":"jpa/#jakarta-ee-example-project","title":"Jakarta EE Example Project","text":"<p>The Jakarta EE example is available at: https://github.com/hantsy/jakartaee11-sandbox/tree/master/persistence. This sample project demonstrates the integration of Jakarta Persistence 3.2 and CDI in the Jakarta EE environment. It requires Jakarta EE application servers, such as GlassFish 8.x or WildFly Preview 37+, to run the sample project.</p> <p>In this project, you do not need to add an extra persistence provider dependency. Jakarta EE application servers contain a built-in Persistence provider that is shared among all applications running on the server.</p> <p>Here we configured EclipseLink to generate static metamodel classes(of course, the previous <code>hibernate-processor</code> also works):</p> <pre><code>&lt;plugins&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${maven-compiler-plugin.version}&lt;/version&gt;\n        &lt;configuration&gt;\n            &lt;parameters&gt;true&lt;/parameters&gt;\n            &lt;annotationProcessorPaths&gt;\n                &lt;annotationProcessorPath&gt;\n                    &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;\n                    &lt;artifactId&gt;org.eclipse.persistence.jpa.modelgen.processor&lt;/artifactId&gt;\n                    &lt;version&gt;${eclipselink.version}&lt;/version&gt;\n                &lt;/annotationProcessorPath&gt;\n            &lt;/annotationProcessorPaths&gt;\n        &lt;/configuration&gt;\n    &lt;/plugin&gt;\n&lt;/plugins&gt;\n</code></pre> <p>To run the tests on a managed Glassfish, execute the following command in a terminal window:</p> <pre><code>mvn clean verify -Parq-managed-glassfish\n</code></pre> <p>It utilizes the GlassFish Managed Adapter for Arquillian and runs tests on the real GlassFish servers.</p> <p>[!NOTE] For more information about Arquillian, visit https://www.arquillian.org.</p>"},{"location":"jpa/#summary","title":"Summary","text":"<p>In summary, Jakarta Persistence 3.2 introduces a range of enhancements, such as improved JPQL syntax, backported SQL functions, modernized support for Java Date and Time types, streamlined configuration options, and deeper integration with Jakarta EE and CDI. For comprehensive details, see the Jakarta Persistence 3.2 specification.</p>"},{"location":"news/","title":"Jakarta EE 11 Web Profile is GA: A New Era for Enterprise Java Development","text":"<p>In a highly anticipated move by the global Java development community, Jakarta EE 11 has officially been launched, marking a significant milestone in enterprise-level Java development. This release introduces a new phase for the framework, offering enhanced functionalities and optimized developer experiences.</p> <p>[!NOTE] As of the release announcement, the Jakarta Platform codes have been tagged with the official version, signifying the completion of all Jakarta EE 11 specifications, following the earlier releases of the Core Profile and Web Profile.</p>"},{"location":"news/#the-evolution-of-jakarta-ee","title":"The Evolution of Jakarta EE","text":"<p>Since the Eclipse Foundation took over the development of Java EE, Jakarta EE has undergone consistent evolution while maintaining its stability:</p> <ul> <li>Jakarta EE 8 and 9: Focused on migrating the namespace from <code>javax</code> to <code>jakarta</code> to resolve legal issues related to Java's trademark.</li> <li>Jakarta EE 10: Introduced the Core Profile, solidifying the importance of CDI and revitalizing the ecosystem. Spring 6 was aligned with this release.</li> <li>Jakarta EE 11: Advances developer experience, sets Java 17 as the baseline, and supports Java 21 runtime. The upcoming Spring 7 will align with this version.</li> </ul>"},{"location":"news/#key-highlights","title":"Key Highlights","text":""},{"location":"news/#new-specification-jakarta-data","title":"New Specification: Jakarta Data","text":"<p>A standout feature of Jakarta EE 11 is the introduction of Jakarta Data, dedicated to data processing. After two years of incubation and development, Jakarta Data officially joins the Jakarta EE ecosystem, filling a crucial gap in enterprise Java frameworks. For more details, visit the Jakarta Data Specification Documentation.</p>"},{"location":"news/#comprehensive-support-for-java-record-type","title":"Comprehensive Support for Java <code>record</code> Type","text":"<p>Jakarta EE 11 elevates Java's <code>record</code> type to a first-class citizen, significantly simplifying data modeling. Various specifications, including Persistence, Faces, Expression Language, and Validation, now fully support this feature.</p>"},{"location":"news/#major-specification-updates","title":"Major Specification Updates","text":"<ul> <li>CDI 4.1: Introduces the ability to use <code>@Priority</code> with <code>@Produces</code>.</li> <li>Concurrency 3.1: Adds support for Java 21's virtual threads and Reactive Streams.</li> <li>REST 4.0: Includes JSON Merge Patch functionality.</li> <li>Security 4.0: Features an in-memory <code>IdentityStore</code> implementation and multi-authentication mechanisms.</li> </ul>"},{"location":"news/#specification-cleanup-and-optimization","title":"Specification Cleanup and Optimization","text":"<ul> <li>The <code>ManagedBean</code> specification has been removed. All existing <code>ManagedBean</code> code must migrate to CDI.</li> <li>SOAP-based Web Service specifications are now deprecated and are no longer recommended for new projects.</li> </ul>"},{"location":"news/#a-community-driven-future","title":"A Community-Driven Future","text":"<p>As a fully community-driven project, Jakarta EE's future is brimming with possibilities. Ongoing discussions around features like Jakarta RPC, Jakarta NoSQL, and Jakarta MVC may shape the next chapters of Jakarta EE's development.</p>"},{"location":"news/#join-the-jakarta-ee-journey","title":"Join the Jakarta EE Journey","text":"<p>The release of Jakarta EE 11 is not just a step forward for enterprise Java but a leap for the developer community. For more information, explore:</p> <ul> <li>Official Website: https://jakarta.ee</li> <li>JakartaOne: https://jakartaone.org. Stay tuned for JakartaONE 2025 LiveStream and the Chinese Community Special Session.</li> <li>Slack: JakartaEE Development</li> </ul> <p>If you are excited about the future of Jakarta EE, consider participating in the official Developer Survey to help shape its direction!</p>"},{"location":"record/","title":"Java Record Support in Jakarta EE 11","text":"<p>Java records are a special kind of class designed to hold immutable data and automatically provide implementations for common methods such as <code>equals()</code>, <code>hashCode()</code>, and <code>toString()</code>.</p> <p>In Jakarta EE 11, Java records are treated as first-class citizens. Specifications such as Jakarta Persistence, Jakarta Validation, and Jakarta Expression Language (EL) fully embrace and support Java records.</p>"},{"location":"record/#jakarta-persistence","title":"Jakarta Persistence","text":"<p>Records can be used as embeddable fields and identifier fields within an entity.</p> <p>For example, if the <code>@Entity</code> <code>People</code> has an embeddable field <code>address</code>, we can create the <code>@Embeddable</code> <code>Address</code> as a Java record:</p> <pre><code>@Embeddable\npublic record Address(\n    String street,\n    String city,\n    String zipCode\n) {}\n</code></pre> <p>And then use it in the <code>People</code> entity:</p> <pre><code>@Entity\npublic class People {\n    @Id Long id;\n    String name;\n    @Embedded Address address;\n    // setters and getters\n}\n</code></pre> <p>Here is an example of using a Java record as the identifier of an entity.</p> <p>First, define the <code>SocialSecurityNumber</code> record:</p> <pre><code>record SocialSecurityNumber(String ssn) {}\n</code></pre> <p>Then, use it as the identifier in the <code>People</code> entity:</p> <pre><code>@Entity\npublic class People {\n    @EmbeddedId SocialSecurityNumber id;\n    String name;\n    // setters and getters\n}\n</code></pre> <p>It can also be used as an <code>@IdClass</code> when combining several fields as the identifier of an entity.</p> <p>For example, define the <code>PersonId</code> record:</p> <pre><code>public record PersonId(Long id, String email) {}\n</code></pre> <p>Then, use it as the identifier in the <code>Person</code> entity:</p> <pre><code>@Entity\n@IdClass(PersonId.class)\npublic class Person {\n    @Id Long id;\n    @Id String email;\n    String name;\n    // setters and getters\n}\n</code></pre> <p>[!NOTE] Due to the dependency of the <code>@Entity</code> class on runtime proxies and the immutable nature of records, records cannot be used as entities.</p>"},{"location":"record/#jakarta-validation","title":"Jakarta Validation","text":"<p>Similar to normal Java classes, Jakarta Validation annotations can be applied to Java record fields. See the following examples.</p> <pre><code>public record People(\n    @NotNull Long id,\n    @NotNull String name,\n    @Email String email,\n    @Valid Address address\n) {\n\n    record Address(\n        @NotNull String street,\n        @NotNull String city,\n        @Pattern(regexp = \"\\\\d{5}\") String zipCode\n    ) {}\n}\n</code></pre> <p>Create an instance of <code>People</code> and use the <code>Validator</code> to check for any violations of the validation rules applied to its fields.</p> <pre><code>var people = new People(1L, \"Hantsy Bai\", \"hantsy.bai@example.com\", new People.Address(\"123 Main St\", \"Anytown\", \"12345\"));\n\nvar validator = Validation.buildDefaultValidatorFactory().getValidator();\nvar violations = validator.validate(people);\n\nviolations.stream().forEach(System.out::println);\n</code></pre> <p>[!NOTE] In the Jakarta EE environment, validation checks are automatically triggered within various components, including EJBs, CDI beans, REST resources, and Jakarta Persistence entities.</p>"},{"location":"record/#jakarta-expression-language","title":"Jakarta Expression Language","text":"<p>In Jakarta EE 10 and earlier versions, to access the component fields of a Java record instance, you must use the accessor methods.</p> <p>For example, using the <code>People</code> and <code>Address</code> records example from above:</p> <pre><code>var elProcessor = new ELProcessor();\nelProcessor.defineBean(\"people\", new People(1L, \"Hantsy Bai\", \"hantsy.bai@example.com\", new People.Address(\"123 Main St\", \"Anytown\", \"12345\")));\n</code></pre> <p>Before Jakarta EE 11, you could access the record fields using accessor methods.</p> <pre><code>elProcessor.eval(\"people.address().street()\");\n</code></pre> <p>In Jakarta EE 11, you can access the fields like other normal Java classes.</p> <pre><code>elProcessor.eval(\"people.address.street\");\n</code></pre> <p>[!NOTE] Jakarta Faces relies on Jakarta Expression Language, allowing you to use records as properties in the backing bean for immutable data on Facelets pages.</p>"},{"location":"record/#jakarta-json-binding","title":"Jakarta JSON Binding","text":"<p>[!WARNING] Jakarta JSON Binding (JSON-B) itself has not been updated to explicitly support Java records, see: jakartaee/jsonb-api#278. However, implementations like Eclipse Yasson and Apache Johnzon have already added support for Java records.</p> <p>Like other normal Java classes, you can use JSONB to convert between JSON string and Java records.</p> <p>Here is an example of converting a <code>People</code> object to JSON and converting it back.</p> <p>First, create an instance of <code>People</code> and convert it to JSON:</p> <pre><code>People people = new People(1L, \"Hantsy Bai\", \"hantsy.bai@example.com\", new People.Address(\"123 Main St\", \"Anytown\", \"12345\"));\n\nJsonbConfig config = new JsonbConfig().withFormatting(true);\nJsonb jsonb = JsonbBuilder.create(config);\n\nString json = jsonb.toJson(people);\nSystem.out.println(json);\n</code></pre> <p>To convert the JSON string back to a <code>People</code> object:</p> <pre><code>People deserializedPeople = jsonb.fromJson(json, People.class);\nSystem.out.println(deserializedPeople);\n</code></pre> <p>[!NOTE] Jakarta REST implementations such as Eclipse Jersey and RedHat Resteasy using JSONB for HTTP message encoding/decoding support Java records due to JSONB capabilities.</p>"},{"location":"record/#summary","title":"Summary","text":"<p>While most Jakarta specifications have been updated to support Java records, there are still some exceptions:</p> <ol> <li>Jakarta REST's <code>@BeanParam</code> does not support Java records, see: jakartaee/rest#913.</li> <li>If a Jakarta Messaging payload contains a Java record property or it is a Java record, message sending will fail because Jakarta Messaging requires the payload to implement the <code>Serializable</code> interface, see: jakartaee/messaging#343.</li> <li>CDI does not support Java records as beans, see: jakartaee/cdi#832.</li> </ol> <p>We hope that these issues will be addressed in future Jakarta EE releases.</p>"},{"location":"rest/","title":"What's New in Jakarta REST 4.0","text":"<p>Jakarta REST 4.0 is a major update in Jakarta EE 11, with much of the work focused on housekeeping. For example, there has been significant effort to modernize the Jakarta REST TCK. Additionally, support for the <code>ManagedBean</code> and <code>JAXB</code> specifications has been removed.</p> <p>For developers, there are a few notable API changes:</p> <ul> <li>New convenient methods for checking a header value, especially which contains a token-separated list, including <code>HttpHeaders#containsHeaderString</code>, <code>ClientRequestContext#containsHeaderString</code>, <code>ClientResponseContext#containsHeaderString</code>, <code>ContainerRequestContext#containsHeaderString</code>, and <code>ContainerResponseContext#containsHeaderString</code>.</li> <li>A new method, <code>UriInfo#getMatchedResourceTemplate</code>, to retrieve the URI template for all paths of the current request.</li> <li>Added support for JSON Merge Patch.</li> </ul> <p>The first two are minor improvements. Let's take a closer look at JSON Merge Patch.</p>"},{"location":"rest/#an-introduction-to-json-merge-patch","title":"An Introduction to JSON Merge Patch","text":"<p>JSON Merge Patch is defined in RFC 7386 as follows:</p> <p>This specification defines the JSON merge patch format and processing rules. The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content.</p> <p>Consider the following example JSON document:</p> <pre><code>{\n    \"title\": \"My second article\",\n    \"author\": {\n        \"givenName\": \"Hantsy\",\n        \"familyName\": \"Bai\"\n    },\n    \"tags\": [\"second\", \"article\"],\n    \"content\": \"The content of my second article\"\n}\n</code></pre> <p>Suppose you want to update the tags to <code>\"JAX-RS\", \"RESTEasy\", \"Jersey\"</code> and change the author to <code>\"Jack\", \"Ma\"</code>. You would send a request like this:</p> <pre><code>PATCH /articles/2 HTTP/1.1\nHost: localhost\nContent-Type: application/merge-patch+json\n\n{\n    \"author\": {\n        \"givenName\": \"Jack\",\n        \"familyName\": \"Ma\"\n    },\n    \"tags\": [\"JAX-RS\", \"RESTEasy\", \"Jersey\"]\n}\n</code></pre> <p>The resulting JSON document would be:</p> <pre><code>{\n    \"title\": \"My second article\",\n    \"author\": {\n        \"givenName\": \"Jack\",\n        \"familyName\": \"Ma\"\n    },\n    \"tags\": [\"JAX-RS\", \"RESTEasy\", \"Jersey\"],\n    \"content\": \"The content of my second article\"\n}\n</code></pre> <p>Let's walk through a simple REST resource example to demonstrate this process in code.</p>"},{"location":"rest/#example-project","title":"Example Project","text":"<p>Assume we need to manage a collection of articles, represented by an <code>Article</code> class:</p> <pre><code>// Article.java\npublic record Article(\n        Integer id,\n        String title,\n        Author author,\n        String content,\n        List&lt;String&gt; tags,\n        LocalDateTime publishedAt\n) {\n    public Article withId(int id) {\n        return new Article(id, title, author, content, tags, publishedAt);\n    }\n\n    public Article withTags(List&lt;String&gt; tags) {\n        return new Article(id, title, author, content, tags, publishedAt);\n    }\n\n    public Article withAuthor(Author author) {\n        return new Article(id, title, author, content, tags, publishedAt);\n    }\n}\n\n// Author.java\npublic record Author(String givenName, String familyName) {\n}\n</code></pre> <p>As mentioned in Java SE Record support in Jakarta EE 11, although JSON-B did not fully align with Record support in Jakarta EE 11, Eclipse Yasson already supports serialization and deserialization of records.</p> <p>The <code>ArticleRepository</code> is a simple in-memory repository:</p> <pre><code>@ApplicationScoped\npublic class ArticleRepository {\n    private static final ConcurrentHashMap&lt;Integer, Article&gt; articles = new ConcurrentHashMap&lt;&gt;();\n    private static final AtomicInteger ID_GEN = new AtomicInteger(1);\n\n    static {\n        var id1 = ID_GEN.getAndIncrement();\n        articles.put(\n            id1,\n            new Article(id1, \"My first article\",\n                new Author(\"Hantsy\", \"Bai\"),\n                \"This is my first article\",\n                List.of(\"first\", \"article\"),\n                LocalDateTime.now())\n        );\n        var id2 = ID_GEN.getAndIncrement();\n        articles.put(id2,\n            new Article(id2, \"My second article\",\n                new Author(\"Hantsy\", \"Bai\"),\n                \"This is my second article\",\n                List.of(\"second\", \"article\"),\n                LocalDateTime.now())\n        );\n    }\n\n    public List&lt;Article&gt; findAll() {\n        return List.copyOf(articles.values());\n    }\n\n    public Article findById(int id) {\n        return articles.get(id);\n    }\n\n    public Article save(Article article) {\n        if (article.id() == null) {\n            var id = ID_GEN.getAndIncrement();\n            article = article.withId(id);\n        }\n        articles.put(article.id(), article);\n        return article;\n    }\n}\n</code></pre> <p>Now, let's look at the <code>ArticleResource</code>:</p> <pre><code>@Path(\"articles\")\n@RequestScoped\npublic class ArticleResource {\n\n    @Inject\n    ArticleRepository repository;\n\n    Jsonb jsonb;\n\n    @PostConstruct\n    public void init() {\n        jsonb = JsonbBuilder.create();\n    }\n\n    @GET\n    public Response getArticles() {\n        return Response.ok(repository.findAll()).build();\n    }\n\n    @GET\n    @Path(\"{id}\")\n    public Response getArticle(@PathParam(\"id\") Integer id) {\n        return Response.ok(repository.findById(id)).build();\n    }\n\n    @POST\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response createArticle(Article article) {\n        var saved = repository.save(article);\n        return Response.created(URI.create(\"/articles/\" + saved.id())).build();\n    }\n\n    @PATCH\n    @Consumes(MediaType.APPLICATION_JSON_PATCH_JSON)\n    public Response saveOrUpdateAllArticles(JsonArray patch) {\n        var all = repository.findAll();\n        var result = Json.createPatch(patch)\n            .apply(Json.createReader(new StringReader(jsonb.toJson(all))).readArray());\n        List&lt;Article&gt; articles = jsonb.fromJson(\n            jsonb.toJson(result),\n            new ArrayList&lt;Article&gt;() {}.getClass().getGenericSuperclass()\n        );\n        articles.forEach(repository::save);\n\n        return Response.noContent().build();\n    }\n\n    @PATCH\n    @Path(\"{id}\")\n    @Consumes(MediaType.APPLICATION_JSON_PATCH_JSON)\n    public Response updateArticle(@PathParam(\"id\") Integer id, JsonArray patch) {\n        var target = repository.findById(id);\n        var patchedResult = Json.createPatch(patch)\n            .apply(Json.createReader(new StringReader(jsonb.toJson(target))).readObject());\n        var article = jsonb.fromJson(jsonb.toJson(patchedResult), Article.class);\n        repository.save(article);\n\n        return Response.noContent().build();\n    }\n\n    @PATCH\n    @Path(\"{id}\")\n    //@Consumes(MediaType.APPLICATION_MERGE_PATCH_JSON) // added in 4.0\n    @Consumes(\"application/merge-patch+json\")\n    public Response mergeArticle(@PathParam(\"id\") Integer id, JsonObject patch) {\n        var targetArticle = repository.findById(id);\n        var mergedResult = Json.createMergePatch(patch)\n            .apply(Json.createReader(new StringReader(jsonb.toJson(targetArticle))).readObject());\n        var article = jsonb.fromJson(jsonb.toJson(mergedResult), Article.class);\n        repository.save(article);\n\n        return Response.noContent().build();\n    }\n}\n</code></pre> <p>For comparison, we also include two JSON Patch (defined by RFC 6902 and implemented in Java EE 8/JAX-RS 2.1) example endpoints: one for processing an array of operations, and another for handling a single resource entity.</p> <p>Let's create an Arquillian test to verify the functionality:</p> <pre><code>@ExtendWith(ArquillianExtension.class)\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class ArticleResourceTest {\n\n    private static final Logger LOGGER = Logger.getLogger(ArticleResourceTest.class.getName());\n\n    @Deployment(testable = false)\n    public static WebArchive createDeployment() {\n        File[] extraJars = Maven\n            .resolver()\n            .loadPomFromFile(\"pom.xml\")\n            .importCompileAndRuntimeDependencies()\n            .resolve(\"org.assertj:assertj-core\")\n            .withTransitivity()\n            .asFile();\n        var war = ShrinkWrap.create(WebArchive.class, \"test.war\")\n            .addAsLibraries(extraJars)\n            .addClasses(\n                ArticleResource.class,\n                Article.class,\n                Author.class,\n                ArticleRepository.class,\n                // jaxrs config\n                JsonbContextResolver.class,\n                RestActivator.class\n            )\n            .addAsWebInfResource(EmptyAsset.INSTANCE, \"beans.xml\");\n        LOGGER.log(Level.INFO, \"war deployment: {0}\", war.toString(true));\n        return war;\n    }\n\n    @ArquillianResource\n    private URL baseUrl;\n\n    Client client;\n\n    private Jsonb jsonb = JsonbBuilder.create();\n\n    @BeforeEach\n    public void before() {\n        LOGGER.log(Level.INFO, \"baseURL: {0}\", baseUrl.toExternalForm());\n        client = ClientBuilder.newClient();\n        client.register(JsonbContextResolver.class);\n    }\n\n    @AfterEach\n    public void after() {\n        client.close();\n    }\n\n    @Test\n    @RunAsClient\n    @Order(1)\n    public void testGetArticles() {\n        var target = client.target(URI.create(baseUrl.toExternalForm() + \"api/articles\"));\n        List&lt;Article&gt; articleList;\n        try (Response r = target.request().accept(MediaType.APPLICATION_JSON_TYPE).get()) {\n            LOGGER.log(Level.INFO, \"Get response status: {0}\", r.getStatus());\n            assertEquals(200, r.getStatus());\n            articleList = r.readEntity(new GenericType&lt;&gt;() {});\n            LOGGER.log(Level.INFO, \"all articles: {0}\", articleList);\n            assertThat(articleList.size()).isEqualTo(2);\n        }\n\n        // Apply JSON Patch\n        var patch = Json.createPatchBuilder()\n            .replace(\"/1/content\", \"Updated by JsonPatch\")\n            .remove(\"/1/author/familyName\")\n            .add(\"/1/tags/1\", \"JAX-RS\")\n            .build().toJsonArray();\n\n        var target2 = client\n            .property(HttpUrlConnectorProvider.SET_METHOD_WORKAROUND, true)\n            .target(URI.create(baseUrl.toExternalForm() + \"api/articles\"));\n        try (Response r2 = target2\n            .request()\n            .method(\"PATCH\", Entity.entity(patch, MediaType.APPLICATION_JSON_PATCH_JSON_TYPE))) {\n            LOGGER.log(Level.INFO, \"patch response status: {0}\", r2.getStatus());\n            assertEquals(204, r2.getStatus());\n        }\n\n        // Verify the patched result\n        try (Response r = target.request().accept(MediaType.APPLICATION_JSON_TYPE).get()) {\n            LOGGER.log(Level.INFO, \"Get response status after applying patch: {0}\", r.getStatus());\n            assertEquals(200, r.getStatus());\n            articleList = r.readEntity(new GenericType&lt;&gt;() {});\n            LOGGER.log(Level.INFO, \"all articles after applying patch: {0}\", articleList);\n            assertThat(articleList.size()).isEqualTo(2);\n        }\n    }\n\n    @Test\n    @RunAsClient\n    @Order(2)\n    public void testGetArticleById() {\n        var target = client.target(URI.create(baseUrl.toExternalForm() + \"api/articles/1\"));\n        try (Response r = target.request().accept(MediaType.APPLICATION_JSON_TYPE).get()) {\n            LOGGER.log(Level.INFO, \"Get response status: {0}\", r.getStatus());\n            assertEquals(200, r.getStatus());\n            Article article = r.readEntity(Article.class);\n            LOGGER.log(Level.INFO, \"get article by id: {0}\", article);\n            assertThat(article.title()).isEqualTo(\"My first article\");\n        }\n\n        var patch = Json.createPatchBuilder()\n            .replace(\"/title\", \"My title updated by JsonPatch\")\n            .build().toJsonArray();\n\n        var target2 = client\n            .property(HttpUrlConnectorProvider.SET_METHOD_WORKAROUND, true)\n            .target(URI.create(baseUrl.toExternalForm() + \"api/articles/1\"));\n        try (Response r2 = target2\n            .request()\n            .method(\"PATCH\", Entity.entity(patch, MediaType.APPLICATION_JSON_PATCH_JSON_TYPE))) {\n            LOGGER.log(Level.INFO, \"patch response status: {0}\", r2.getStatus());\n            assertEquals(204, r2.getStatus());\n        }\n\n        // Verify the patched result\n        try (Response r = target.request().accept(MediaType.APPLICATION_JSON_TYPE).get()) {\n            LOGGER.log(Level.INFO, \"Get response status after applying patch: {0}\", r.getStatus());\n            assertEquals(200, r.getStatus());\n            Article article = r.readEntity(Article.class);\n            LOGGER.log(Level.INFO, \"get article by id after applying patch: {0}\", article);\n            assertThat(article.title()).isEqualTo(\"My title updated by JsonPatch\");\n        }\n    }\n\n    @Test\n    @RunAsClient\n    @Order(3)\n    public void testGetArticleByIdAndMergePatch() {\n        var target = client.target(URI.create(baseUrl.toExternalForm() + \"api/articles/2\"));\n        Article article = null;\n        try (Response r = target.request().accept(MediaType.APPLICATION_JSON_TYPE).get()) {\n            LOGGER.log(Level.INFO, \"Get response status: {0}\", r.getStatus());\n            assertEquals(200, r.getStatus());\n            article = r.readEntity(Article.class);\n            LOGGER.log(Level.INFO, \"get article by id: {0}\", article);\n            assertThat(article.title()).isEqualTo(\"My second article\");\n        }\n\n        var updated = article.withTags(List.of(\"JAX-RS\", \"RESTEasy\", \"Jersey\"))\n            .withAuthor(new Author(\"Jack\", \"Ma\"));\n        var patch = Json.createMergeDiff(\n            Json.createReader(new StringReader(jsonb.toJson(article))).readObject(),\n            Json.createReader(new StringReader(jsonb.toJson(updated))).readObject()\n        ).toJsonValue();\n\n        var target2 = client\n            .property(HttpUrlConnectorProvider.SET_METHOD_WORKAROUND, true)\n            .target(URI.create(baseUrl.toExternalForm() + \"api/articles/2\"));\n        try (Response r2 = target2\n            .request()\n            .method(\"PATCH\", Entity.entity(patch, \"application/merge-patch+json\"))) {\n            LOGGER.log(Level.INFO, \"patch response status: {0}\", r2.getStatus());\n            assertEquals(204, r2.getStatus());\n        }\n\n        // Verify the patched result\n        try (Response r = target.request().accept(MediaType.APPLICATION_JSON_TYPE).get()) {\n            LOGGER.log(Level.INFO, \"Get response status after applying patch: {0}\", r.getStatus());\n            assertEquals(200, r.getStatus());\n            article = r.readEntity(Article.class);\n            LOGGER.log(Level.INFO, \"get article by id after applying patch: {0}\", article);\n            assertThat(article.title()).isEqualTo(\"My second article\");\n            assertThat(article.tags()).isEqualTo(List.of(\"JAX-RS\", \"RESTEasy\", \"Jersey\"));\n            assertThat(article.author()).isEqualTo(new Author(\"Jack\", \"Ma\"));\n        }\n    }\n}\n</code></pre> <p>In the above test:</p> <ul> <li>The deployment is marked as testable, meaning the test runs as a client and interacts with the service deployed in the test archive.</li> <li>After deployment, the <code>@ArquillianResource</code>-annotated <code>URL</code> provides the application's base URL, including the <code>ApplicationPath</code> defined in the <code>Application</code> class, ending with a <code>/</code>.</li> <li>We set <code>.property(HttpUrlConnectorProvider.SET_METHOD_WORKAROUND, true)</code> to ensure the custom <code>PATCH</code> method works correctly with the current Jakarta REST Client API.</li> </ul> <p>Let's focus on the <code>testGetArticleByIdAndMergePatch</code> test method, which demonstrates the JSON Merge Patch functionality:</p> <ul> <li>First, retrieve the resource.</li> <li>Modify it and use <code>Json.createMergeDiff</code> to create a patch <code>JsonObject</code>.</li> <li>Apply the patch to the remote resource.</li> <li>Finally, retrieve the resource again to verify that the patch was applied successfully.</li> </ul> <p>[!WARNING] The Jakarta REST Client API does not provide a <code>patch()</code> method, similar to the existing <code>get()</code> or <code>post()</code>. See the related discussion: jakartaee/rest#1276.</p> <p>Get the complete example project from my GitHub repository. </p>"},{"location":"rest/#final-thoughts","title":"Final Thoughts","text":"<p>Over the past decade, I have developed many backend RESTful API applications. However, I have noticed a growing trend: more customers are choosing Spring WebMvc or WebFlux as their preferred frameworks over Jakarta REST. While libraries and frameworks like RESTEasy and Quarkus help fill some gaps, Jakarta REST itself has evolved slowly. Features like JSON Patch and the new JSON Merge Patch introduced in this version are rarely used in real-world RESTful API development. Even Spring once incubated a project called Spring Sync to address similar needs, but it has since been abandoned.</p> <p>In my view, since version 2.1, Jakarta REST has not delivered significant features that boost developer productivity. The following is my wishlist for the next generation of Jakarta REST.</p> <ul> <li>Deprecating <code>Resource/Context</code> injection in favor of CDI <code>@Inject</code> (jakartaee/rest#951, jakartaee/rest#569), and replacing <code>@Provider</code> with CDI <code>@Produces</code> or programmatic configuration in the <code>Application</code> class.</li> <li>Supporting async/reactive return types natively, as has been available in Quarkus for years, and moving <code>@Suspended AsyncResponse</code> handling to background concurrency and context propagation (jakartaee/rest#1281).</li> <li>Providing default values for query, form, and path parameter names (jakartaee/rest#579).</li> <li>Adding support for Problem Details (jakartaee/rest#1150).</li> <li>Adding support for API Versioning (jakartaee/rest#1317).</li> <li>Adding support for Hypermedia, eg, HAL, HAL Form, etc. (jakartaee/rest#1323).</li> <li>Supporting Java records in FormBeans and related areas (jakartaee/rest#955, jakartaee/rest#913), especially since records are a major feature in EE 11.</li> <li>Enabling functional programming styles for both client and server code (jakartaee/rest#1301).</li> <li>Defining HTTP service interfaces as contracts between client and server (jakartaee/rest#1294).</li> <li>Modernizing the client API to use Java 8+ syntax and making the HTTP client engine easily switchable (jakartaee/rest#1282).</li> <li>...</li> </ul> <p>I hope the Jakarta REST expert group will focus more on features that improve developer productivity and address real-world needs.</p>"},{"location":"security/","title":"What's New in Jakarta Security 4.0","text":"<p>The Jakarta Security specification offers a set of user-friendly APIs for managing authentication and authorization in Jakarta EE applications. It builds upon Jakarta Authentication and Jakarta Authorization, while providing developers with enhanced control and flexibility.</p> <p>Version 4.0 brings several notable improvements, including:</p> <ul> <li>A standardized in-memory <code>IdentityStore</code></li> <li>CDI qualifiers for built-in authentication mechanisms</li> <li>A handler for processing multiple authentication mechanisms</li> </ul>"},{"location":"security/#in-memory-identitystore","title":"In-Memory IdentityStore","text":"<p>Earlier versions of the Jakarta Security implementation\u2014Eclipse Soteria already included an in-memory identity store. With version 4.0, this feature is now officially standardized as part of the Jakarta Security specification.</p> <p>Here\u2019s how you can use the in-memory <code>IdentityStore</code>:</p> <pre><code>@InMemoryIdentityStoreDefinition(\n    value = {\n        @Credentials(callerName = \"admin\", password = \"password\", groups = {\"web\", \"rest\"}),\n        @Credentials(callerName = \"webuser\", password = \"password\", groups = {\"web\"}),\n        @Credentials(callerName = \"restuser\", password = \"password\", groups = {\"rest\"})\n    }\n)\n@DeclareRoles({\"web\", \"rest\"})\n@ApplicationScoped\npublic class SecurityConfig {\n}\n</code></pre> <p>In this example, two roles - <code>web</code> and <code>rest</code> are defined, along with three users: <code>admin</code>, <code>webuser</code>, and <code>restuser</code>. All credentials are stored in memory.</p> <p>[!NOTE] The in-memory <code>IdentityStore</code> is intended for testing only, as it keeps user credentials in memory. For production, it\u2019s recommended to use a database-backed <code>IdentityStore</code> to securely persist user credentials.</p>"},{"location":"security/#cdi-qualifiers-for-built-in-authentication-mechanisms","title":"CDI Qualifiers for Built-in Authentication Mechanisms","text":"<p>To enhance CDI integration, Jakarta Security 4.0 introduces a <code>qualifiers</code> attribute to the built-in <code>XXXAuthenticationMechanismDefinition</code> annotations. This allows you to identify authentication mechanism resources as CDI beans and inject them using custom qualifiers.</p> <p>For example, if you want to use both the basic authentication mechanism and a custom form-based authentication mechanism in your CDI beans, start by creating two custom qualifiers: <code>WebAuthenticationQualifier</code> and <code>RestAuthenticationQualifier</code>.</p> <pre><code>// WebAuthenticationQualifier.java\n@Documented\n@Target({ElementType.TYPE, ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Qualifier\npublic @interface WebAuthenticationQualifier {\n}\n\n// RestAuthenticationQualifier.java\n@Documented\n@Target({ElementType.TYPE, ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Qualifier\npublic @interface RestAuthenticationQualifier {\n}\n</code></pre> <p>Next, declare both <code>@BasicAuthenticationMechanismDefinition</code> and <code>@CustomFormAuthenticationMechanismDefinition</code> in your <code>SecurityConfig</code> class, setting the <code>qualifiers</code> attribute to the custom qualifiers you defined:</p> <pre><code>@BasicAuthenticationMechanismDefinition(\n    realmName = \"BasicAuth\",\n    qualifiers = {RestAuthenticationQualifier.class}\n)\n@CustomFormAuthenticationMechanismDefinition(\n    loginToContinue = @LoginToContinue(\n        loginPage = \"/login.faces\",\n        errorPage = \"/login.faces?error\",\n        useForwardToLogin = false // use redirect\n    ),\n    qualifiers = {WebAuthenticationQualifier.class}\n)\n// ...\n@ApplicationScoped\npublic class SecurityConfig {\n}\n</code></pre> <p>Now, you can inject the declared <code>XXXAuthenticationMechanism</code> as qualified CDI beans in your CDI beans:</p> <pre><code>@ApplicationScoped\npublic class MultipleHttpAuthenticationMechanismHandler implements HttpAuthenticationMechanismHandler {\n    @Inject\n    @RestAuthenticationQualifier\n    private HttpAuthenticationMechanism restAuthenticationMechanism;\n\n    @Inject\n    @WebAuthenticationQualifier\n    private HttpAuthenticationMechanism webAuthenticationMechanism;\n    // ...\n}\n</code></pre>"},{"location":"security/#handling-multiple-authentication-mechanisms","title":"Handling Multiple Authentication Mechanisms","text":"<p>Previously, combining different authentication mechanisms in a Jakarta EE application was challenging using the Jakarta Security APIs. Version 4.0 introduces a new API, <code>HttpAuthenticationMechanismHandler</code>, which lets you handle incoming requests more flexibly.</p> <pre><code>@Alternative\n@Priority(APPLICATION)\n@ApplicationScoped\npublic class MultipleHttpAuthenticationMechanismHandler implements HttpAuthenticationMechanismHandler {\n    private static final Logger LOGGER = Logger.getLogger(MultipleHttpAuthenticationMechanismHandler.class.getName());\n\n    @Inject\n    @RestAuthenticationQualifier\n    private HttpAuthenticationMechanism restAuthenticationMechanism;\n\n    @Inject\n    @WebAuthenticationQualifier\n    private HttpAuthenticationMechanism webAuthenticationMechanism;\n\n    @Override\n    public AuthenticationStatus validateRequest(HttpServletRequest request, HttpServletResponse response, HttpMessageContext httpMessageContext) throws AuthenticationException {\n        String path = request.getRequestURI().substring(request.getContextPath().length());\n        LOGGER.log(Level.INFO, \"Request path (without context path): {0}\", path);\n        if (path.startsWith(\"/api\")) {\n            LOGGER.log(Level.INFO, \"Handling authentication using RestAuthenticationQualifier HttpAuthenticationMechanism...\");\n            return restAuthenticationMechanism.validateRequest(request, response, httpMessageContext);\n        }\n\n        LOGGER.log(Level.INFO, \"Handling authentication using WebAuthenticationQualifier HttpAuthenticationMechanism...\");\n        return webAuthenticationMechanism.validateRequest(request, response, httpMessageContext);\n    }\n}\n</code></pre> <p>In this example, authentication handling is delegated to the injected <code>HttpAuthenticationMechanism</code> instances. Basic authentication is applied to URIs starting with <code>/api</code>, while form-based authentication is used for other web pages.</p> <p>The <code>@Alternative</code> annotation indicates that this bean is an alternative of the built-in bean <code>HttpAuthenticationMechanismHandler</code> provided by the Jakarta EE container, and can replace the existing one at runtime.</p> <p>To activate the <code>MultipleHttpAuthenticationMechanismHandler</code> bean at runtime, you can use the <code>@Priority(APPLICATION)</code> annotation as shown above, or configure it in the CDI beans.xml file as follow:</p> <pre><code>&lt;beans ...&gt;\n    &lt;!-- ... --&gt;\n    &lt;alternatives&gt;\n        &lt;class&gt;com.example.MultipleHttpAuthenticationMechanismHandler&lt;/class&gt;\n    &lt;/alternatives&gt;\n&lt;/beans&gt;\n</code></pre>"},{"location":"security/#example-project","title":"Example Project","text":"<p>The example project demonstrates all the samples covered in this article and also includes additional code snippets, such as <code>@Authenticated</code> and <code>@Authorized(roles)</code>, to illustrate real-world class and method level security protection.</p> <p>To build and run the example project on GlassFish, use the following command:</p> <pre><code>mvn clean package cargo:run -Pglassfish\n</code></pre> <p>To test the web pages, open your browser and navigate to http://localhost:8080/security-examples/test-servlet.</p> <p>You\u2019ll be redirected to the <code>/login</code> page. After logging in with either <code>webuser</code> or <code>admin</code> (as defined earlier), you\u2019ll be taken back to the protected page.</p> <p>To verify that REST API protection works as expected, open a terminal and run:</p> <pre><code>curl -X GET http://localhost:8080/security-examples/api/hello\n</code></pre> <p>You should receive a <code>401 Unauthorized</code> error.</p> <p>Then, try with the predefined <code>restuser/password</code> credentials:</p> <pre><code>curl -X GET http://localhost:8080/security-examples/api/hello -u \"restuser:password\"\n</code></pre> <p>You should see a <code>200</code> status code and the response from the <code>/hello</code> endpoint.</p> <p>The example project also includes a simple test written in JUnit 5 and Arquillian.</p> <p>Open a terminal and run the following command to execute the test:</p> <pre><code>mvn clean verify -P\"arq-glassfish-managed\"\n</code></pre> <p>You can find the complete example project on my GitHub and explore the code locally.</p>"},{"location":"validation/","title":"Jakarta Validation","text":"<p>Jakarta Validation (formerly known as Jakarta Bean Validation) 3.1 mainly adds support for record types, which were introduced in Java SE 11.</p> <p>Let's use an example to illustrate this.</p> <pre><code>// Customer.java\npublic record Customer(\n    @NotBlank\n    String firstName,\n    @NotBlank\n    String lastName,\n\n    @NotNull\n    Optional&lt;@NotNull PhoneNumber&gt; phoneNumber,\n\n    @NotEmpty\n    EmailAddress[] emailAddresses,\n\n    @Valid\n    Address address\n) {\n}\n\n// Address.java\npublic record Address(\n    @NotBlank\n    String street,\n    @NotBlank\n    String city,\n    String state,\n    @NotBlank\n    String zipCode\n) {\n}\n\n// PhoneNumber.java\npublic record PhoneNumber(\n    @NotBlank\n    @Pattern(regexp = \"\\\\d{3,4}\")\n    String countryCode,\n\n    @NotBlank\n    @Pattern(regexp = \"\\\\d{3,11}\")\n    String number\n) {\n}\n\n// EmailAddress.java\npublic record EmailAddress(\n    @Email\n    @NotBlank\n    String email,\n    @NotNull\n    Boolean primary\n) {\n}\n</code></pre> <p>In a Java SE environment, simply add the Jakarta Validation implementation, eg, Hibernate Validator, to the classpath and initialize a <code>Validator</code> instance as follows:</p> <pre><code>Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\n</code></pre> <p>Create a valid <code>Customer</code> instance and validate it using the <code>validator.validate</code> method:</p> <pre><code>var data = new Customer(\n    \"Foo\",\n    \"Bar\",\n    Optional.of(new PhoneNumber(\"001\", \"3334445555\")),\n    new EmailAddress[]{\n        new EmailAddress(\"foo@example.com\", true),\n        new EmailAddress(\"bar@example.com\", false)\n    },\n    new Address(\"123 Main St\", \"Anytown\", \"CA\", \"12345\")\n);\n\nvar constraints = validator.validate(data);\nLOGGER.info(\"Constraints: \" + constraints);\n</code></pre> <p>In the above example, the <code>constraints</code> result is empty.</p> <p>Now, create a new <code>Customer</code> instance with a null phone number:</p> <pre><code>var data = new Customer(\n    \"Foo\",\n    \"Bar\",\n    Optional.empty(),\n    new EmailAddress[]{\n        new EmailAddress(\"foo@example.com\", true),\n        new EmailAddress(\"bar@example.com\", false)\n    },\n    new Address(\"123 Main St\", \"Anytown\", \"CA\", \"12345\")\n);\n\nvar constraints = validator.validate(data);\nLOGGER.info(\"Constraints: \" + constraints);\n</code></pre> <p>When you run the code, the console will print the <code>constraints</code> as follows:</p> <pre><code>INFO: Constraints: [ConstraintViolationImpl{interpolatedMessage='must not be null', propertyPath=phoneNumber, rootBeanClass=class com.example.Customer, messageTemplate='{jakarta.validation.constraints.NotNull.message}'}]\n</code></pre> <p>Next, create another <code>Customer</code> instance without any emails:</p> <pre><code>var data = new Customer(\n    \"Foo\",\n    \"Bar\",\n    Optional.of(new PhoneNumber(\"001\", \"3334445555\")),\n    new EmailAddress[]{},\n    new Address(\"123 Main St\", \"Anytown\", \"CA\", \"12345\")\n);\n\nvar constraints = validator.validate(data);\nLOGGER.info(\"Constraints: \" + constraints);\n</code></pre> <p>You should see the following output in the console:</p> <pre><code>INFO: Constraints: [ConstraintViolationImpl{interpolatedMessage='must not be empty', propertyPath=emailAddresses, rootBeanClass=class com.example.Customer, messageTemplate='{jakarta.validation.constraints.NotEmpty.message}'}]\n</code></pre> <p>Now, create a new <code>Customer</code> with an address that does not have a zip code:</p> <pre><code>var data = new Customer(\n    \"Foo\",\n    \"Bar\",\n    Optional.of(new PhoneNumber(\"001\", \"3334445555\")),\n    new EmailAddress[]{\n        new EmailAddress(\"foo@example.com\", true),\n        new EmailAddress(\"bar@example.com\", false)\n    },\n    new Address(\"123 Main St\", \"Anytown\", \"CA\", null)\n);\n\nvar constraints = validator.validate(data);\nLOGGER.info(\"Constraints: \" + constraints);\n</code></pre> <p>Run the code and you will see the following output in the console:</p> <pre><code>INFO: Constraints: [ConstraintViolationImpl{interpolatedMessage='must not be blank', propertyPath=address.zipCode, rootBeanClass=class com.example.Customer, messageTemplate='{jakarta.validation.constraints.NotBlank.message}'}]\n</code></pre> <p>The <code>validator.validate</code> method returns a set of <code>ConstraintViolation</code> objects, which describe the validation constraints for each property path. If the set is empty, it means the validation was successful.</p>"},{"location":"validation/#example-project","title":"Example Project","text":"<p>Download the example project from GitHub and explore it on your local system. The CustomerTest class contains all the examples shown in this article.</p>"},{"location":"vt/","title":"Virtual Thread Support in Jakarta EE 11","text":"<p>Java 21 introduces Virtual Threads, a lightweight threading solution that allows applications to create a large number of concurrent threads with minimal memory consumption. Unlike Platform Threads, which are resource-intensive and heavily dependent on system processor cores, Virtual Threads are designed to be efficient and scalable. This new feature significantly enhances the concurrency capabilities of Java applications, making it easier to handle high-throughput workloads with improved performance and reduced overhead.</p> <p>Jakarta EE 11 sets Java 17 as the baseline but it also requires all implementations to support Java 21. To align with Java 21, Jakarta Concurrency 3.1 introduces support for virtual threads, enhancing the concurrency capabilities of Jakarta EE applications.</p> <p>In Jakarta Concurrency 3.1, a new attribute <code>virtual</code> is added to existing annotations such as <code>@ManagedExecutorDefinition</code>, <code>@ManagedScheduledExecutorDefinition</code>, and <code>@ManagedThreadFactoryDefinition</code>. This attribute specifies whether to create the managed resources using virtual threads. By default, the virtual thread support is not enabled, the <code>virtual</code> attribute is <code>false</code> implicitly. To enable it, explicitly set the value of the <code>virtual</code> attribute to <code>true</code>.</p> <p>[!NOTE] To leverage Virtual Threads in Jakarta EE, ensure your applications are running on a Jakarta EE 11 implementation with a Java 21+ runtime.</p> <p>For example, declare virtual thread-based resources:</p> <pre><code>@ManagedExecutorDefinition(\n    name = \"java:comp/vtExecutor\",\n    maxAsync = 10,\n    context = \"java:comp/vtContextService\",\n    virtual = true\n)\n@ContextServiceDefinition(\n    name = \"java:comp/vtContextService\",\n    propagated = {SECURITY, APPLICATION}\n)\n@ManagedThreadFactoryDefinition(\n    name = \"java:comp/vtThreadFactory\",\n    context = \"java:comp/vtContextService\",\n    virtual = true\n)\n@ManagedScheduledExecutorDefinition(\n    name = \"java:comp/vtScheduleExecutor\",\n    context = \"java:comp/vtContextService\",\n    maxAsync = 10,\n    virtual = true\n)\n@ApplicationScoped\npublic class VirtualThreadAsyncConfig {\n}\n</code></pre> <p>In this example, a dedicated <code>ContextService</code> is defined specifically for the virtual thread-based resources. This ensures that all related executors and thread factories share a consistent context configuration optimized for virtual thread usage.</p> <p>To utilize these resources within your CDI beans, simply inject them using the <code>@Resource</code> annotation with their respective JNDI names:</p> <pre><code>@Resource(lookup = \"java:comp/vtExecutor\")\nManagedExecutorService executor;\n\n@Resource(lookup = \"java:comp/vtContextService\")\nContextService contextService;\n\n@Resource(lookup = \"java:comp/vtThreadFactory\")\nManagedThreadFactory threadFactory;\n\n@Resource(lookup = \"java:comp/vtScheduleExecutor\")\nManagedScheduledExecutorService scheduledExecutor;\n</code></pre> <p>Alternatively, Jakarta Concurrency 3.1 allows injecting managed resources using CDI <code>@Inject</code>. To distinguish virtual thread-aware resources, use custom CDI <code>@Qualifier</code> annotations. By setting the <code>qualifiers</code> attribute on resource annotations, these resources can be injected type-safely in CDI beans, similar to other CDI beans.</p> <p>For example, create a custom <code>@Qualifier</code> annotation:</p> <pre><code>@Qualifier\n@Retention(RUNTIME)\n@Target({METHOD, FIELD, PARAMETER, TYPE})\npublic @interface WithVirtualThread {\n}\n</code></pre> <p>Next, add the <code>qualifiers</code> attribute to the resource annotations and set its value to the created <code>@Qualifier</code> class.</p> <pre><code>@ManagedExecutorDefinition(\n    //...\n    qualifiers = {WithVirtualThread.class}\n)\n@ContextServiceDefinition(\n       //...\n    qualifiers = {WithVirtualThread.class}\n)\n@ManagedThreadFactoryDefinition(\n    //...\n    qualifiers = {WithVirtualThread.class}\n)\n@ManagedScheduledExecutorDefinition(\n    //...\n    qualifiers = {WithVirtualThread.class}\n)\n@ApplicationScoped\npublic class VirtualThreadAsyncConfig {\n}\n</code></pre> <p>Finally, inject these resources using the custom <code>@Qualifier</code> annotation:</p> <pre><code>@Inject\n@WithVirtualThread\nManagedExecutorService executor;\n\n@Inject\n@WithVirtualThread\nContextService contextService;\n\n@Inject\n@WithVirtualThread\nManagedThreadFactory threadFactory;\n\n@Inject\n@WithVirtualThread\nManagedScheduledExecutorService scheduledExecutor;\n</code></pre> <p>Here are some examples of using these resources to run asynchronous tasks in a Jakarta EE environment:</p> <pre><code>executor.submit(() -&gt; {\n    // Task logic here\n    System.out.println(\"Task executed using ManagedExecutorService\");\n});\n\nscheduledExecutor.schedule(() -&gt; {\n    // Task logic here\n    System.out.println(\"Task scheduled using ManagedScheduledExecutorService\");\n}, 10, TimeUnit.SECONDS);\n\ntry (ForkJoinPool pool = new ForkJoinPool(\n    Runtime.getRuntime().availableProcessors(),\n    threadFactory,\n    (t, e) -&gt; LOGGER.log(Level.INFO, \"Thread: {0}, error: {1}\", new Object[]{t.getName(), e.getMessage()}),\n    true\n)) {\n    pool.submit/invokeAll...\n}\n\ntry (var scope = new StructuredTaskScope(\"vt\", threadFactory)) {\n    Future&lt;String&gt; task1 = scope.fork(() -&gt; {... });\n    Future&lt;Integer&gt; task2 = scope.fork(() -&gt; {... });\n\n    scope.join(); // Wait for all tasks to complete\n    scope.throwIfFailed(); // Propagate any task failure\n\n    // handle the results\n}\n</code></pre> <p>While virtual threads are not a silver bullet for all performance issues, they can significantly enhance overall application performance by increasing throughput in some scenarios, such as database calls, handling HTTP interactions, etc.</p>"}]}